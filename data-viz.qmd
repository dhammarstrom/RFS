---
bibliography: references.bib
editor_options: 
  chunk_output_type: console
reference-location: margin
citation-location: margin
---

# Data visualization

The most apparent purpose of data visualizations in scientific contexts is to convey information not suited for text or tables but for graphical displays like comparisons between categories, relationships among variables, or trends over time [@gelman2002; @tufte2001]. We often think of the scientific graph as the end product of our labor. However, data visualization can be an effective tool for thinking about scientific problems and performing exploratory data analysis before preparing your manuscript. These steps will likely take up more time than polishing *Figure 1* of your upcoming paper.

Data visualization is thus a skill, like writing, with several purposes. You may write notes for yourself and write to communicate with others. Notes come in many forms, just as messages you write to others. Similarly, data visualizations can have different purposes, such as

-   Checking that your data is what could be expected

-   Diagnosing statistical models

-   Exploring a relationship between many variables

-   Showing that your measurements are reliable and valid

-   Conveying the key message from your study

Traditionally, and in many software implementations, data visualization is a matter of choosing from a menu of charts such as box plots, scatter plots, or line graphs. These can be very effective. However, you would not restrict your writing to pre-made templates. As a professional scientist in a quantitative genre, you need a toolbox for data visualizations that do not limit you. By using a *grammar of graphics* you can be more creative in designing your visualizations.

## A grammar of graphics - `ggplot2`

Building on Wilkinsons *The Grammar of Graphics* [@wilkinson2005], Wickham [@wickham2010; @wickham2016] implemented a graphical grammar to R through the package `ggplot2`. The idea behind both Wickhams and Wilkinsons formalized syntax for creating data visualizations is to avoid special cases or duplicate methods and allow for creation of data visualizations based on a set of core components used in all graphics [@wickham2010; @wilkinson2005].

The grammar (in the version described by Wickham [@wickham2010]) has seven components that together creates a ggplot2 visualization (@fig-ggplotlayers).

The underlying **data** contains the variables that are **mapped to aesthetics** such as coordinates, colors or shapes. Each aesthetic can be controlled through **scales** by assigning values to coordinates, colors, shapes etc. **Geometric objects** creates the visual representations of the mapping. Sometimes small multiples of the same graph are created using **facets** which creates subdivision of the data to be plotted in different panels. **Statistical transformations** creates summaries of the data, however, in its simplest form, the transformation is the identity transformation. All graphical representations are plotted in a **coordinate** system. **Theme and annotations** adds non-data layers to the plot which can include geometric shapes or text (@fig-ggplotlayers).

```{r}
#| echo: false
#| warning: false
#| message: false
#| label: fig-ggplotlayers
#| fig-cap: "Components of a ggplot2 visualization"

library(tidyverse)

## Create a data frame for plotting a rectangle that is tilted to look like a plane in 3D
parallelogram_data <- data.frame(
  x = rep(c(1, 4, 6, 3), 7),
  y = rep(c(1.5, 1.5, 3, 3), 7),
  col = rep(c("a", "b", "c", "d", "e", "f", "g"), each = 4), 
  add = rep(c(1, 2, 3, 4, 5, 6, 7), each = 4)) %>%
  mutate(y = y + add)

# Plot the parallelogram using ggplot2
ggplot() +
  geom_polygon(data = parallelogram_data, aes(x = x, y = y, fill = col), color = "black", alpha = 0.3) +
  coord_fixed(ratio = 1) +  # This is to ensure that the x and y axis are on the same scale
  geom_text(data = data.frame(y = seq(1:7) + 2, 
                              lab = c("Data", "Aesthetics",
                                      "Geometric objects", "Facets", 
                                      "Statistical\ntransformations", 
                                      "Coordinates", "Theme and\n annotations")), 
            aes(x = 0.5, y = y, label = lab), 
            hjust = 1) +
  
  scale_x_continuous(limits = c(-2, 6)) +

  theme_void() + 
  theme(legend.position = "none")



```

### Building blocks of a plot

Using a similar example as in [@wickham2010] a basic plot can be broken down into the data (see @tbl-ggplotdataexample), geometric objects, scales and coordinates and annotations. These components, that can be individually manipulated, together creates the final plot (see @fig-ggplotexample a-d).

```{r}
#| echo: false
#| warning: false
#| message: false
#| label: tbl-ggplotdataexample
#| tbl-cap: "Example data for a ggplot"


library(tidyverse); library(gt)

data.frame(x = c(1, 2.4, 4, 5.2), 
           y = c(3, 2, 5, 7.8), 
      
           shape = c("a", "a", "b", "b")) %>%
  gt()



```

```{r}
#| echo: false
#| warning: false
#| message: false
#| label: fig-ggplotexample
#| fig-cap: "Three components, geometric objects (a), coordinates and scales (b) and plot annotations (c) are constitues of the complete plot (d)"
library(cowplot)

a <- data.frame(x = c(1, 2.4, 4, 5.2), 
           y = c(3, 2, 5, 7.8), 
           color = c("s", "m", "s", "m"), 
           shape = c("a", "a", "b", "b"), 
           size = c(2, 3, 4, 5)) %>%
  ggplot(aes(x, y, shape = shape)) + geom_point(size = 3) + 
  theme_void() +
  theme(legend.position = "none")
 
b <- data.frame(x = c(1, 2.4, 4, 5.2), 
           y = c(3, 2, 5, 7.8), 
           color = c("s", "m", "s", "m"), 
           shape = c("a", "a", "b", "b"), 
           size = c(2, 3, 4, 5)) %>%
  ggplot(aes(x, y, shape = shape))  + 
  theme_classic() +
  theme(legend.position = "none", 
        axis.text = element_blank(), 
        axis.title = element_blank())

c <- data.frame(x = c(1, 2.4, 4, 5.2), 
           y = c(3, 2, 5, 7.8), 
           color = c("s", "m", "s", "m"), 
           shape = c("a", "a", "b", "b"), 
           size = c(2, 3, 4, 5)) %>%
  ggplot(aes(x, y, shape = shape))  + 
  theme_classic() +
  geom_point(color = "white") + 
  labs(title = "Title", 
       subtitle = "Subtitle", 
       x = "x-axis", 
       y = "y-axis", 
       shape = "legend") +
  
  theme(axis.ticks = element_blank(), 
        axis.line = element_blank())


d <- data.frame(x = c(1, 2.4, 4, 5.2), 
           y = c(3, 2, 5, 7.8), 
           color = c("s", "m", "s", "m"), 
           shape = c("a", "a", "b", "b"), 
           size = c(2, 3, 4, 5)) %>%
  ggplot(aes(x, y, shape = shape))  + 
  theme_classic() +
  geom_point(color = "black", size = 3) + 
  labs(title = "Title", 
       subtitle = "Subtitle", 
       x = "x-axis", 
       y = "y-axis", 
       shape = "legend") +
  
  theme()


plot_grid(
    plot_grid(a, b, c, nrow = 1, align = "vh", 
              labels = c("a", "b", "c"), 
          rel_widths = c(0.8, 0.8, 1)), 
    plot_grid(NULL, d, NULL, rel_widths = c(0.7, 1, 0.7),
              nrow = 1,
              labels = c("", "d", "")), 
    nrow = 2)

```

The corresponding code to create this plot is fairly straight forward:

```{r}
#| eval: false
#| echo: true

library(ggplot2)

df <- data.frame(x = c(1, 2.4, 4, 5.2),  # <1> 
           y = c(3, 2, 5, 7.8), 
           shape = c("a", "a", "b", "b")) 


  ggplot(data = df,                      # <2>
         mapping = aes(x = x, y = y, shape = shape))  +    # <3>

  geom_point(color = "black", size = 3) + # <4>
  
    labs(title = "Title",        # <5>
       subtitle = "Subtitle", 
       x = "x-axis", 
       y = "y-axis", 
       shape = "legend") +
    theme_classic() # <6>


```

1.  A simple data frame is saved containing the variables we will plot
2.  The data is explicitly called
3.  Variables are mapped to coordinates (x and y) and shapes.
4.  Geometric objects (points) are specified with color and size determined in the function
5.  Annotations are added to the plot through the `labs` (labels) function.
6.  A pre-built theme is used to change the default appearance of the plot.





## Before plotting

As we saw above, a basic visualization can be created from a data set, or a data frame which is the most common representation of data in R. A *tidy* data set has one observation per row and one variable per column. A tidy data set makes data visualization easy. However, not all data sets are friendly. In fact, some might be unfriendly because they are unhappy[^unhappy].

::: {.column-margin}

[^unhappy]: The reference to happiness is a reference to @wickham2014 wherein Tolstoy's Anna Karenina is quoted; "Happy families are all alike; every unhappy family is unhappy in its own way." The Anna Karenina principle applies to data as non-tidy data can be non-tidy in many ways, tidy data however are tidy because they all share a common set of features.

:::

A lot of effort goes into making data sets suitable for visualization or statistical modelling. The good news is that R is especially suited for the process of importing and wrangling data. As with other common tasks in R there are numerous ways of achieving the same goals. This is a good thing because it allows for solutions to a wide range of problems. It is also a bad thing because it makes it difficult to getting started. A collection of R packages called the [Tidyverse](https://www.tidyverse.org/) makes the process of getting started with data wrangling easier. 

Tidyverse can be thought of as a dialect of the R language. The dialect is designed to make it easy to write sequential operations in a way that translates thoughts and ideas to code. Sequential operations are enabled by a pipe operator. Using a pipe operator we can call functions in sequential order to do specific operations on the data. We can write such a pipe as demonstrated below with the corresponding English language descriptions to the left. 


:::: {.columns}

::: {.column width="60%"}

Take the data ***then do***<br>
filter the data based on *x* larger than 10 ***then do***<br>
add a new calculated variable z = x + y ***then do***<br>
show the output<br>

:::

::: {.column width="40%"}


```{r}
#| echo: true
#| eval: false

data |>
  filter(x > 10) |>
  mutate(z = x + y) |>
  print()


```


:::

::::

The pipe operator (`|>`) takes any input and place it as the first argument in the following function[^funnote]. This is the mechanism that makes sequential operations possible. A pipe operator makes code more readable, consider the following two alternatives:

::: {.margin-column}

[^funnote]: A function is a basic building block of your R code. Function are designed for specific tasks and can be part of packages or created by the user. A function may take arguments such as `fun(<ARGUMENT1> = <default input>, <ARGUMNET2> = <default input>)`. Arguments can be used without explicitly naming them by putting expected input in at the right position. Orders of argument may be changed is argument names are used.  

:::



```{r}
#| eval: false
#| echo: true

print(mutate(filter(select(data, var1:var3), var1 == "xxx"), var4 = var1 + var2)) # <1>


data |> # <2>
  select(var1:var3) |>
  filter(var1 == "xxx") |>
  mutate(var4 = var1 + var2) 


```

1. Alternative 1: A number of operations are performed on data, we have to read from in to out to see each step.
2. Alternative 2: The same steps are performed as in alternative 1, in the same order. 

The pipe in alternative 2 are structured with the pipe operator making the code more readable and easier to edit. Notice that the same functions are used in both cases. 

In R there are two main pipe operators. We have the "base R" pipe, `|>`. This pipe operator is included in the base installation of R and available without loading any packages on start up. A second pipe belongs to the `magritter` package. The `magritter` pipe (`%>%`) has the same basic functionality as the base pipe; the left hand input is inserted as the first argument in any right hand function. 

Sometimes you might want to place your input somewhere else than as the first argument in a right hand function. A placeholder can be used to indicate where you would like to place your input. The base pipe differs from the `magritter` pipe in what symbol indicates a placeholder. In the example below, the function `some_fun()` expects data as the third argument. We need to use our placeholder to put the data in the correct position:


```{r}
#| eval: false
#| echo: true

data |> # <1>
  some_fun(arg1 = c(1, 2), 
           arg2 = "some.setting", 
           arg3 = _)


library(tidyverse)
data %>% # <2>
  some_fun(arg1 = c(1, 2), 
           arg2 = "some.setting", 
           arg3 = .)



```

1. With the base R forward pipe operator.
2. With the `magritter` forward pipe operator. 





### Reading data into R

Three packages makes reading tabular data into R easy. `readr` provides functions for reading and writing delimiter separated files, such as `.csv` or `.tsv`. `readxl` provides functions that imports data from excel files. An finally, `googlesheets4` makes it possible to read tabular data created in google sheets.


Data can also be loaded from packages in R since storing data is a convenient way of sharing. By including data in a package you are nudged to do some quality checks and document it. We will talk more about data packages in a later workshop. 



### The verbs of data wrangling

Once data is available in our workspace we will be able to wrangle it. In the examples below I will use a data set containing results from dual x-ray absorptiometry measurements available in the `exscidata` package. To install the `exscidata` package:

```{r}
#| echo: true
#| eval: false

library(remotes)
install_github("dhammarstrom/exscidata")

```

The `dplyr`package provides a collection of verbs to facilitate wrangling. As mentioned above, "pipeable" functions takes a data frame as its first argument. This means that we can line up functions in sequential order using a pipe operator. In all verb functions, following the data argument follows a set of arguments that specifies what we wish to do with the data. The result of the operations performed by the function are returned as a data frame. 

`dplyr` contains the following main data verbs:

- `select`
- `rename`
- `relocate`
- `mutate`
- `filter`
- `arrange`
- `summarize` 

In addition, several helper function will aid our wrangling endeavors.

`dplyr` is loaded as part of the `tidyverse` package:

```{r}
#| echo: true
#| eval: false
#| message: false

library(tidyverse)

```


#### Select, rename and relocate variables

Variables in a data frame may be selected and renamed. Such operation may have multiple purposes such as giving you a better overview of the data of interest or limiting what data to display in a table. Renaming can make life easier if the data set contains long variable names. 

Below we will store a subset of the data in a new data set. But we will first have a look at what column names are available:

```{r}

library(exscidata) # <1>
glimpse(exscidata::dxadata) # <2>

```

1. Loading the `exscidata` package
2. Using `glimbse` we will get a overview of all available variables in the data set. The double `::` means that we are looking for the data set `dxadata` inside the package `exscidata`.


The data set contains `r dim(exscidata::dxadata)[1]` rows and `r dim(exscidata::dxadata)[2]` columns. The variables in the data set are described as part of the `exscidata` package and can be seen by typing `?dxadata` in the console.

We will work further with lean body mass data, these are variables starting with `lean.`. In addition we need variables describing observations like `participant`, `time`, `multiple`, `single`, `sex`, `include`, `height` and `weight`. To select these variables we can try a couple of different approaches. 
The `select` function can select variables by name. This means that we can simply list them: 


```{r}

exscidata::dxadata |> # <1> 
  select(participant, time, multiple, single) |> # <2>
  print() # <3>
  
```

1. Retrieve the data from the `exscidata` package
2. select variables based on names
3. Print the resulting data frame.

The above approach means a lot of work writing all columns names in the select call. An alternative approach is to select variables based on the first and last variable in a sequence. This is possible by using the syntax `<first column>:<last column>`. 

```{r}

exscidata::dxadata |>  
  select(participant:weight) |> # <1>
  print() 
  
```

1. Selecting by the first and last column in a sequence.

We also like to have the lean body mass data included in our new data set. Since all variables containing lean body mass data starts with `lean.` we can use a helper function to select them. Two alternatives are possible:


```{r}


exscidata::dxadata |>  
  select(participant:weight, starts_with("lean.")) |> # <1>
  print() 


exscidata::dxadata |>  
  select(participant:weight, contains("lean.")) |> # <2>
  print() 


```

1. Using `starts_with` to select all columns that starts with `lean.`
2. Using `contains`to select all variables that contains `lean.`

There are other select helper functions such as `ends_with` and `matches` that work in a similar fashion as the above. `all_of` and `any_of` helps you select variables based on a vector of variables, `where` selects based on where a function of your choosing returns true. See `?select` for a complete list.

In a `select` call we can also rename variables using the syntax `<new name> = <old name>`. Let's say we want to select and rename `participant`:

```{r}


exscidata::dxadata |>  
  select(parti = participant, time:weight, starts_with("lean.")) |> 
  print() 



```

Notice how different ways of selecting variables can be combined in `select`.

The `rename` function makes it easy to rename variables without the need to select.


```{r}

exscidata::dxadata |>  
  select(participant:weight, starts_with("lean.")) |> 
  rename(parti = participant) |>
  print() 


```


If we want to change the order of variables in a data set we can specify the order in a select call, or use `relocate`

```{r}

exscidata::dxadata |>  
  select(participant:weight, starts_with("lean.")) |> 
  relocate(lean.whole) |>
  print() 

```

`relocate` puts the selected variable as the first column in the data set. If we want to specify the location we can use the arguments `.before` or `.after`. 

```{r}

exscidata::dxadata |>  
  select(participant:weight, starts_with("lean.")) |> 
  relocate(lean.whole, .after = sex) |>
  print() 

```

#### Creating new variables 

`mutate` let's us create new variables in a data set. These can be a function of variables already in the data set or created from our input. 

Let's create a variable representing the percentage of lean mass to body mass.

```{r}

exscidata::dxadata |>  
  select(participant:weight, starts_with("lean.")) |> 
  mutate(rel_lean_whole = 100 * ((lean.whole/1000) / weight)) |>
  relocate(rel_lean_whole) |>
  print() 

```


### From wide to long and back again

The `dxadata` data set is not a tidy data set. It contains two variables (`single` and `multiple`) that indicates which leg has been training with low and moderate volume respectively [@hammarstrom2020]. Additionally, lean mass variables could be separated based on body half (right or left). To compare training volume we need to reformat the data set. We will start by making a smaller data set that indicate training volume per leg. 

As we have already seen, `participant`, `single` and `multiple` are the variables needed to make a data set that indicates training volume per leg, per participant. We will start by selecting these columns followed by pivoting the data as the volume data is located in two variables. This essentially means that we will make the data set longer.  

```{r}

exscidata::dxadata |>  
  select(participant, multiple, single) |> # <1>
  pivot_longer(values_to = "leg", names_to = "volume",  cols = multiple:single) %>% # <2>
  print()
  


```

1. Selecting our variables of interest
2. Creating a long data set based on volume data spread over two columns.

As we see we now have a long data set, but it is longer than expected. The original data contains only `r length(pull(distinct(exscidata::dxadata, participant), participant))` participants. As each participant has two legs we would expect 82 observations. Above we did not remove post-intervention observations and we therefore have several duplicates. This can be taken care of by using the `distinct` function which returns unique observations across a combination of variables.


```{r}

participant_volume <- exscidata::dxadata |>  
  select(participant, multiple, single) |> # 
  pivot_longer(values_to = "leg", names_to = "volume",  cols = multiple:single) %>%
  distinct(participant, volume, leg) %>% # <1>
  print()
  
```

1. Removes all duplicate combinations of `participant`, `volume` and `leg`.

We can save our smaller data set as `participant_volume`

Next we want to create a data set of right and left leg lean mass data. We will start by selecting variables.

```{r}

exscidata::dxadata |>  
  select(participant, time, starts_with("lean.") & ends_with("_leg")) |> #
  print()



```

Notice how `&` was used to create a conditional selection of variables. I addition to selecting time, include[^incl] and participant we select variables that starts with `lean.` AND ends with `_leg`. 

::: {.column-margin}

[^incl]: The variable `incl` is used to indicate which participants to include in a final analysis. Included participants completed a given set of training sessions.

:::

The resulting data set is wide. Two variables contains the same variable (lean mass), but one variable (leg) is lurking in two variables (`lean.left_leg` and `lean.right_leg`). Let's make the data set long.


```{r}

leg_leanmass <- exscidata::dxadata |>   # <3>
  select(participant, time, include, starts_with("lean.") & ends_with("_leg")) |> 
  pivot_longer(names_to = "leg", values_to = "lean_mass", cols = contains("lean.")) |> # <1>
  mutate(leg = if_else(leg == "lean.left_leg", "L", "R")) |> # <2>
  
  print()



```

1. Notice how select helpers can be used in pivot_longer.
2. We use `mutate` together with `if_else` to change the leg indicator to `R` and `L`
3. We save the data set as `leg_leanmass`


`pivot_longer` has a brother called `pivot_wider`, this functions performs the reverse operation making long data sets wide. Let's say that we would like to calculate the paired difference of leg lean mass from pre to post, we could make a wider data set and calculate `post - pre`



```{r}

exscidata::dxadata |>  
  select(participant, time, include, starts_with("lean.") & ends_with("_leg")) |> 
  pivot_longer(names_to = "leg", values_to = "lean_mass", cols = contains("lean.")) |>
  mutate(leg = if_else(leg == "lean.left_leg", "L", "R")) |> 
  pivot_wider(names_from = time, values_from = lean_mass) |> # <1> 
  mutate(delta_lean_mass = post - pre) |> # <2>
  print()

```

1. Pivot wider creates new columns based on names in `time` and values in `lean_mass`
2. The new variables is calculated as the difference between pre and post-intervention values.

### Joining data sets
We have constructed two smaller data sets, one indicating which leg performed low and moderate volume and one data set containing the lean mass values for each leg, pre- and post-intervention. Next step is to join the two.

`dplyr` contains functions for joining data frames. There are, as illustrated in @fig-join-illustration important differences between the functions where outer joins (left, right and full) keeps all observations in `x`, `y` and both `x` and `y` respectively. `inner_join` however, drops unmatched observations from both input data frames. Unlike the others, `anti_join` function removes observations in `x` that is present in `y`.

```{r}
#| code-fold: true
#| code-summary: Code producing the figure
#| message: false
#| warning: false
#| label: fig-join-illustration
#| fig-cap: "Functions for joining data sets."


library(ggVennDiagram) 
library(ggplot2) 
library(cowplot)

# Joins can be illustrated with venn diagrams.
# We do not need information about sets etc only 
# a way to fill three distinct areas. 
# The ggVennDiagram contains a function creating 
# shapes to be filled.


lst <- process_data(Venn(list(x = c("1"), y = c("1"))))

# To avoid repeated code, create a function that plots
# venn diagrams with options to indicate a title and 
# specify fill colors
join_illustration <- function(lst, 
                              fills = c("steelblue", 
                                        "steelblue", 
                                        "white"), 
                              title = "left_join(x,y)") {
  
  ggplot() + 
    
  geom_sf(aes(fill = id), data = venn_region(lst), 
          color = "black") +
  
  theme_void() +
  # Hard coded labels
  geom_text(aes(x = c(300, 700), 
                y = c(500, 500), 
                label = c("x", "y")), 
            size = 8, 
            color = "gray20") +
  
  
  scale_fill_manual(values = fills) +
  
  labs(title = title) +
  
  theme(legend.position = "none")
  
  
}


# Each join gets its own fig. All figures are 
# ombined below with plot_grid from cowplot.

left <- join_illustration(lst = lst, 
                  title = "left_join(x,y)", 
                  fills = c("steelblue", "steelblue", "white"))
right <- join_illustration(lst = lst, 
                  title = "right_join(x,y)", 
                  fills = c("white", "steelblue", "steelblue"))
inner <- join_illustration(lst = lst, 
                  title = "inner_join(x,y)", 
                  fills = c("white", "steelblue", "white"))
full <- join_illustration(lst = lst, 
                  title = "full_join(x,y)", 
                  fills = c("steelblue", "steelblue", "steelblue"))
anti <- join_illustration(lst = lst, 
                  title = "anti_join(x,y)", 
                  fills = c("steelblue", "white", "white"))


plot_grid(left, right, inner, full, anti, ncol = 2)

```

Our two data sets are pretty insensitive to dropped observations since the two data sets should be complete. We will use a `left_join` to put the data set together. This will match participant and leg because these two variables exists in both data sets. If we want to join by other variables we may specify such a variable. We'll save the joined data set as `leg_leanmass`.

```{r}

leg_leanmass <- leg_leanmass |>
  inner_join(participant_volume) |>
  print()

```

### Filters and sorting rows

We included the variable `include` in our data set, this will make it possible to get rid of observations from participants that should be part of the final analysis. We can use `filter` to perform this operation.

```{r}
leg_leanmass |>
  filter(include == "incl") |>
  print()
```

The double equal sign can be read as "equal to" in R, a common source of confusion is that the single equal sign (`=`) is used as a assignment operator.[^assignop]

::: {.margin-column}

[^assignop]: An assignment operator is used to assign data values to objects stored in the work space. The commonly used `<-` is equivalent to `=`. Note however that `->` is different from `=`.  

:::

The `filter` function keeps rows of a data frame where a condition that we specify returns `TRUE`. To construct testable conditions that allows for results being either `FALSE` or `TRUE` we will use one, or a combination operators, such as

| | |
|--- | ---|
| `==` |&rarr; "equal to"|
| `!=` |&rarr; "not equal to"|
| `>` |&rarr; "larger than"|
| `<` |&rarr; "smaller than"|
| `>=`, `<=` |&rarr; "larger/smaller or equal to"|
| `!` |&rarr; "NOT"|
| `&` |&rarr; "AND"|
| `|` |&rarr; "OR" |


The above are all part of a collection of logical operators.[^logicoperators]
We may demonstrate the mechanism by which `filter` operates by creating our own vector of `TRUE`/`FALSE` values. In the code chunk below a vector (`INCLUDE`) is created based on our `include` variable. A `logical` vector is created from the statement `INCLUDE != "excl"`. We then use this vector in the filter statement. 

::: {.margin-column}

[^logicoperators]: See [here](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Logic.html) for a technical overview of logical operators.

:::


```{r}

INCLUDE <- leg_leanmass |>
  pull(include)

INCLUDE <- INCLUDE != "excl"


INCLUDE

leg_leanmass |>
  filter(INCLUDE)



```


In R, a vector of `TRUE`/`FALSE` (or in short form `T`/`F`) are is a special case which R will prohibit us from overwriting.

#### Grouped filters

Using the dplyr syntax it is easy to e.g. filter or mutate based on a grouping of the data set. The function `group_by` creates a grouped data set. In the context of filtering in our data set we may want to filter out observations larger than the median from two time points.

```{r}

leg_leanmass |>
  group_by(time) |>
  filter(lean_mass > median(lean_mass)) |> 
  print()


```

The above operation removed exactly half of the observations, as expected since we wanted observations larger than the median from both time points. We may combine this statement with filtering away `"excl"` from the `include` variable.

```{r}

leg_leanmass |>
  group_by(time) |>
  filter(include != "excl", lean_mass > median(lean_mass)) |> 
  print()


```

Putting two conditions in a `filter` call is like explicitly using `&` (AND) to combine statements. All conditions must evaluate to be `TRUE` for the row to be included in final output.

An alternative to grouping by the `group_by` function is to do a "per-operation grouping"[^perop] using the `.by` argument. This does not leave a grouping in the data frame after filtering.

[^perop]: See `?dplyr_by`

```{r}

leg_leanmass |>
  filter(include != "excl", lean_mass > median(lean_mass), .by = time) |> 
  print()


```


### Summaries

We often want to reduce larger amount of data into some summaries, such as means, standard deviations, medians etc. These summaries may be calculated over any number of categorical variables representing e.g. groups of observations. Just like in the filtering statement above, we may work with a grouped data frame, or by using a per-operation grouping (`.by`).

We will calculate the median, first and third quartile, and minimum and maximum from each volume condition and time point. Below are both of the two alternatives of grouping used. 

```{r}

leg_leanmass |>
  filter(include != "excl") |>
  group_by(time, volume) |>
  summarise(Min = min(lean_mass), 
            q25 = quantile(lean_mass, 0.25), 
            Median = median(lean_mass), 
            q75 = quantile(lean_mass, 0.75), 
            Max = max(lean_mass)) |>
  print()
  

leanmass_sum <- leg_leanmass |>
  filter(include != "excl") |>
  summarise(Min = min(lean_mass), 
            q25 = quantile(lean_mass, 0.25), 
            Median = median(lean_mass), 
            q75 = quantile(lean_mass, 0.75), 
            Max = max(lean_mass), 
            .by = c(time, volume)) |>
  print()



```

Notice how the data frames either have a persistent grouping, or no grouping depending on how we invoked grouping. Notice also that all values are nicely displayed, this is not always the case with summarise. 

Consider the following example

```{r}

vals <- c(4.5, 6.7, 4.6, 5.1, NA)

mean(vals)

```

The mean of a vector of values containing a missing value returns `NA`. If we where to have missing values (`NA`) in our original data we would have recievied a `NA` in results. To drop an `NA` from such a summary we need to specify `na.rm = TRUE` as part of a summary function. 

```{r}

vals <- c(4.5, 6.7, 4.6, 5.1, NA)

mean(vals, na.rm = TRUE)

```

R does not drop `NA` silently! This is a good thing as we want to get a notice when we are missing data. If we know we are missing data we need to explicitly type this in our calls. This "rule" is not always true as some functions silently drops `NA`, be aware!

### Arranging data frames

At last we might want to arrange a data frame for ease of use, or prior to making a table etc. Arranging does not change the data frame *per se*, only how it is displayed. 

We'll used our summarized data frame from above and sort based on the `volume` variable. 

```{r}

leanmass_sum |>
  arrange(volume) |>
  print()

```

Any other column will also work for arranging

```{r}

leanmass_sum |>
  arrange(Median) |>
  print()

```

Using a helper function (`desc`) reverses the sorting 

```{r}

leanmass_sum |>
  arrange(desc(Median)) |>
  print()

```

Notice that `desc` also works for character data

```{r}

leanmass_sum |>
  arrange(desc(volume)) |>
  print()

```


## `ggplot` examples

As hinted above, `ggplot2` presents us with almost endless opportunities for graphical representations of our data. We will use the data we have wrangled above to better understand the `ggplot2` syntax.

In our summary of the lean mass data we have calculated a number of summary statistics that can be used to create a type of range-quartile-median plot not unlike the plots suggested by Tukey[^tukey]. We will use time as a categorical variable on the x-axis and our summary statistics displayed on the y-axis.

[^tukey]: Tukey [-@tukey1977] is considered to be creator of the box-plot. However, Spear may have suggested a predecessor to the box-plot in Charting statistics [@spear1952]. 

```{r}

ggplot(data = leanmass_sum, aes(time, Median))

```

We have specified a data set, and variables for the x and y axis. This specification gives us an empty coordinate system. We need to add geometric objects to represent the data mapped to x and y coordinates. Let's start simple

```{r}

ggplot(data = leanmass_sum, aes(time, Median)) +
    geom_point()

```

The points now represents our median values per time point. There are a number of geometric objects, or geoms in `ggplot2`. You are also able to extend `ggplot2` by creating your own geoms, this has been done in many packages to make a specific geometric available. In `ggplot2` there are about 50 geoms available and in addition, a number of statistical transformations[^geoms].

::: {.margin-column}

[^geoms]: See https://ggplot2.tidyverse.org/reference/ for a complete inventory.

:::

In our plot in the making, instead of points we may add rectangular shapes with a bit of reorganization of the data.

```{r}

leanmass_sum |>
  mutate(Time = if_else(time == "pre", 1, 2)) |>
  ggplot( aes(Time, Median, fill = volume)) +
    
  geom_rect(aes(xmin = Time - 0.18, 
                  xmax = Time + 0.18, 
                  ymin = Median, 
                  ymax = q75), 
            color = "black", 
            position = position_dodge(width = 0.4)) + 
  
  geom_rect(aes(xmin = Time - 0.18, 
                  xmax = Time + 0.18, 
                  ymin = q25, 
                  ymax = Median), 
            color = "black", 
            position = position_dodge(width = 0.4))
  


```

We have hacked our way to a plot showing the median as a line inside a box covering the interquartile range. Let's add bars representing the minimum and maximum values. Note that we are using layers and we want our range bars to not over plot the boxes. We must therefore add them prior to the boxes. We will also scale the x-axis and add labels.  

```{r}

leanmass_sum |>
  mutate(Time = if_else(time == "pre", 1, 2)) |>
  ggplot( aes(Time, Median, fill = volume)) +
    
  
  geom_errorbar(aes(ymin = Min, ymax = Max), 
                position = position_dodge(width = 0.4), 
                width = 0) + 
  
  
  geom_rect(aes(xmin = Time - 0.18, 
                  xmax = Time + 0.18, 
                  ymin = Median, 
                  ymax = q75), 
            color = "black", 
            position = position_dodge(width = 0.4)) + 
  
  
  geom_rect(aes(xmin = Time - 0.18, 
                  xmax = Time + 0.18, 
                  ymin = q25, 
                  ymax = Median), 
            color = "black", 
            position = position_dodge(width = 0.4)) +
  
  scale_x_continuous(limits = c(0.75, 2.25), 
                     breaks = c(1, 2), 
                     labels = c("pre", "post"))
  
  


```

Do not bother creating the above figure! This is an example of the flexibility brought to us by using a set of simple geometric objects. There are shortcuts to the above plot that takes care of a couple of default operations. We need our data prior to being summarized with additional preparatory steps:

```{r}

leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot()


```

The new plot is a box-plot showing the same statistical transformations that we made by hand using a categorical x-axis with the time-values sorted as a factor.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A direct comparison between (a) manual statistical summaries (transformations) and built in transformations in ggplot2 (b)."



a <- leanmass_sum |>
  mutate(Time = if_else(time == "pre", 1, 2)) |>
  ggplot( aes(Time, Median, fill = volume)) +
    
  
  geom_errorbar(aes(ymin = Min, ymax = Max), 
                position = position_dodge(width = 0.4), 
                width = 0) + 
  
  
  geom_rect(aes(xmin = Time - 0.18, 
                  xmax = Time + 0.18, 
                  ymin = Median, 
                  ymax = q75), 
            color = "black", 
            position = position_dodge(width = 0.4)) + 
  
  
  geom_rect(aes(xmin = Time - 0.18, 
                  xmax = Time + 0.18, 
                  ymin = q25, 
                  ymax = Median), 
            color = "black", 
            position = position_dodge(width = 0.4)) +
  
  scale_x_continuous(limits = c(0.75, 2.25), 
                     breaks = c(1, 2), 
                     labels = c("pre", "post")) + 
  theme(legend.position = "bottom")
  
  


b <- leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() + 
  theme(legend.position = "bottom")



plot_grid(a, b, labels = c("a", "b"), ncol = 2)


```


We have seen that `ggplot2` have some built in features that makes statistical transformation, but also that a similar result can be obtained by using other "geoms" such as `geom_rect`. Again, this allows for flexible creation of data visualizations. 

### Labels and themes
So far we have used the available data to determine what is being represented in the figure. To make the figure closer to "publication ready" we would want to take control over labels, colors and shapes that so far are presented with variable names and default settings.

The `labs` function adds customized labels to a ggplot. All aesthetic mappings are available for labeling. We will go further with the box-plot which uses x, y and fill as aesthetics mapped to data.

```{r}


leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  
  labs(x = "Time", 
       y = "Leg lean mass (g)", 
       fill = "Volume condition")


```

Additionally, we might want to think about if we need all axis labels. The time variable is specified with `pre` and `post` and won't need a overall axis label. Instead we might want to clean up the axis text. Since this is a data-driven element in our figure we can change it's behavior prior to plotting. We have already changed the order of the factor, let's add labels to each level and remove the overall `Time` label.


```{r}

leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"), 
                       labels = c("Pre\nintervention", 
                                  "Post\nintervention"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  
  labs(x = "Time", 
       y = "Leg lean mass (g)", 
       fill = "Volume condition") +
  
  theme(axis.title.x = element_blank())



```

Notice that we removed the "Time" label from the figure by removing it in the theme function (`theme(axis.title.x = element_blank())`; more about that later). The factor variable `time` was re-specified using the `factor` function. This function takes a character or factor variable and specifies levels (the order of factors) and optionally, labels for each level.

An alternative approach to changing the labels of the factor is to include labels in a call to `scale_x_discrete`.

```{r}

leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  
  labs(x = "Time", 
       y = "Leg lean mass (g)", 
       fill = "Volume condition") +
  
  scale_x_discrete(labels = c("Pre\nintervention", 
                                  "Post\nintervention")) +
  
  
  theme(axis.title.x = element_blank())



```

#### Theming
`ggplot2` has a very flexible system for changing parts of a figure that are not directly connected to the data (i.e. created from aesthetic mapping). Each element in the theme that can be controlled is listed in the help pages for `theme`, type `?theme` in your console to access it.

The below illustrates some of the main components we might want to consider:

```{r}


leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  
  labs(x = "Time", 
       y = "Leg lean mass (g)", 
       fill = "Volume condition", 
       title = "The plot title", 
       subtitle = "The plot subtitle", 
       caption = "the plot caption") +
  
  scale_x_discrete(labels = c("Pre\nintervention", 
                                  "Post\nintervention")) +
  
  
  theme(axis.title.x = element_blank(), 
        legend.position = "top",
        axis.title = element_text(color = "yellow"),
        axis.text = element_text(color = "green"), 
        axis.ticks = element_line(color = "yellow", linewidth = 2), 
        axis.line = element_line(color = "blue", linewidth = 2), 
        panel.background = element_rect(fill = "gray50"), 
        panel.grid.major = element_line(color = "pink", linewidth = 2), 
        panel.grid.minor = element_line(color = "magenta", linewidth = 2), 
        plot.background = element_rect(fill = "darkblue"), 
        legend.background = element_rect(fill = "navyblue"), 
        legend.key = element_rect(fill = "gray"), 
        legend.text = element_text(color = "yellow"), 
        legend.title = element_text(color = "magenta"), 
        plot.caption = element_text(color = "yellow"),
        plot.title = element_text(color = "lightgreen"),
        plot.subtitle = element_text(color = "pink"))





```


Each element of the theme can be modified with an element function. The theme element `axis.title` is a text element and must subsequently be modified with `element_text()`. This function takes a number of arguments making it possible to modify text components. Below we use our basic plot and to modify the y axis title.


```{r}


leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  
  labs(x = "Time", 
       y = "Leg lean\nmass (g)", 
       fill = "Volume condition", 
       title = "The plot title", 
       subtitle = "The plot subtitle", 
       caption = "the plot caption") +
  
  scale_x_discrete(labels = c("Pre\nintervention", 
                                  "Post\nintervention")) +
  
  
  theme(axis.title.x = element_blank(), 
        legend.position = "top",
        axis.title.y = element_text(color = "black", 
                                  family = "mono",
                                  face = "bold",
                            
                                  size = 20,
                                  hjust = 0.5,
                                  vjust = 0.5,
                                  angle = 45,
                                  lineheight = 2),
        )





```


The element `axis.title.y` is similar to `axis.title.x` and if we want we could use `axis.title` to modify both for common attributes. Notice also that we have changed multiple numbers that have defaults. The `size` is the size of the text, `hjust` and `vjust` controls horizontal and vertical placement, receptively.`angle` rotates the text and `lineheight` controls the distance between lines (we have used `\n` to indicate a new line in the title).

Similarly to `element_text`, `element_rect` contains argument to control rectangular elements and `element_line` is used to control lines. `element_blank` is used to remove an element, we already used this above to remove the x axis title. In the same "family" of function we find `margin` which can specify margins of theme elements.

In addition to controlling specific elements of a theme we have the option to use ready made themes. A couple of pre-specified themes are shipped with `ggplot2` (see @fig-theme-example)



```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "Examples of themes that are part of `ggplot2`" 
#| label: fig-theme-example
#| fig-height: 12


p <- leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  
  labs(x = "Time", 
       y = "Leg lean\nmass (g)", 
       fill = "Volume condition", 
       
       subtitle = "The plot subtitle", 
       caption = "the plot caption") +
  
  scale_x_discrete(labels = c("Pre\nintervention", 
                                  "Post\nintervention"))




plot_grid(p + theme_bw() + labs(title = "theme_bw"), 
          p + theme_classic()+ labs(title = "theme_classic"), 
          p + theme_minimal()+ labs(title = "theme_minimal"), 
          p + theme_dark()+ labs(title = "theme_dark"), 
          p + theme_light()+ labs(title = "theme_light"), 
          p + theme_linedraw()+ labs(title = "theme_linedraw"), 
          p + theme_bw()+ labs(title = "theme_bw"), 
          p + theme_grey()+ labs(title = "theme_grey"), 
          p + theme_void()+ labs(title = "theme_void"), 
          ncol = 2)



```


## Scientific graphic design

An important rule of scientific graphics is, not to lie. Or as stated by Tufte [-@tufte2001], "graphical excellence begins with telling the truth about the data". Clear and honest representation of the data together with detailed labeling are key factors for avoiding lies [@tufte2001]. 

Another key aspect in the construction of scientific graphs is to decide what to plot. Graphs are very good at showing differences, however, what differences should be show? In a two-group design (treatment vs. control) we should aim at showing the difference between groups, not the difference within groups [@ho2019]. When data are grouped, or measurements repeated within experimental units (such as research participants), we should show aim at indicating this fact. When graphical summaries are shown, we should also aim at showing the underlying data[@tufte2001].   

### Revise and edit
When trying to find a coherent guide for scientific graphics one quickly realize that guidelines are often in conflict with each other. We have to reach some pragmatic level of compromise in our work. How do we find this compromise? Tufte's advice to constantly revise and edit is a good start [@tufte2001]. Like with writing we try to explain or show, but fail to do so. Multiple edits later our text is ready to communicate an idea to others, and we might have learned something too.

In practice a graph, or a collection of graphs are born from multiple revisions. Below we will revise our graph using a number of principles outlined by Tufte [@tufte2001].

#### Show the data

Our original idea is shown below. We made a box-plot of raw lean mass values. A core shortcoming of this graph is that it hides uncertainty our sample size. We could add another layer on top of our bow-plots to show raw data. The geom `geom_point` is added with the additional arguments: `shape = 21, position =position_jitterdodge(dodge.width = 0.75, jitter.width = 0.1)`. The change in shape creates the possibility to fill points. As we have specified fill in aesthetics each point will have a condition-wise fill. 


```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A boxplot with raw data plotted on top" 



leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  geom_point(shape = 21, position = position_jitterdodge(dodge.width = 0.75, 
                                                         jitter.width = 0.1))
  
  

```

Are we showing the data now? Some aspects of the data are still lost. The fact that the experiment is a nested one is not obvious from this display. Could we connect related data points?

In the next graph we'll try another alternative, using a line-graph we might be able to convey an aspect of the repeated measures design. We will also add a facet to show each volume condition.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouping observations per participant and volume condition"


leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume, group = participant)) + 
  
  geom_line() +
  geom_point(shape = 21) + 
  facet_grid(. ~ volume)

```

But what is the real comparison here? Here we might actually display within-condition differences. The analog to statistical test might be that we show two within-condition t-tests and tell the reader that the effect in one group is greater than the other. This is not an honest test. 

To revise further we might want to compare changes across conditions. We can do this and still highlight comparisons within participants since each participant performed both conditions. To accomplish this we need some data wrangling.

```{r}

delta_lean <- leg_leanmass |>
  filter(include != "excl") |> # <1>
  pivot_wider(names_from = time, values_from = lean_mass) |> # <2>
  mutate(delta = post - pre) |> # <3>
  print()

```

1. Using only included participants from our raw data set we first...
2. create a wide data set by time allowing for...
3. a simple difference across time in each participant and condition. 

We have saved the data set in a new object called `delta_lean` we will use this for plotting.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions"


delta_lean |>
  ggplot(aes(volume, delta, fill = volume, group = participant)) + 
  geom_line() + 
  geom_point(shape = 21)
  
  
```

It could be argued that the order of the factor variable `volume` is not accurately representing the data. Multiple is larger than single and the graph might be more accurate in this respect if we change this variable. I will do it as a pre-plotting operation. We may then also change the labels.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions"


delta_lean |>
  
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  
  ggplot(aes(volume, delta, 
             fill = volume, 
             group = participant)) + 
  geom_line() + 
  geom_point(shape = 21) 
  
  
  
```


#### Maximize the data-ink ratio
A guiding principle in Tufte' guideline is to remove non-data ink. We should aim to maximize the amount of ink used to display the data. Non-data ink can be removed by manipulating theme components. A great start might be to use a built in theme, `theme_minimal`.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions, reducing non-data ink with `theme_minimal`."


delta_lean |>
  
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  
  ggplot(aes(volume, delta, 
             fill = volume, 
             group = participant)) + 
  geom_line() + 
  geom_point(shape = 21) +
  
  theme_minimal()
  
```

The legend is redundant, it can be removed since this information is already present in the x axis. The x-axis title is redundant as the information is duplicated in the labels. Some grid lines can be removed without loss of information, maybe even all of them. Let's add a line manually to show the 0 change. We can access these options using the `theme` function and elements manipulated therein. Placing the `theme` after `theme_minimal` in our call makes sure that we don't bring back elements from the pre-built theme. Let's also add a more descriptive label on the y-axis.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions, reducing non-data ink with `theme_minimal`."


delta_lean |>
  
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  
  ggplot(aes(volume, delta, 
             fill = volume, 
             group = participant)) + 
  
  geom_hline(yintercept = 0, color = "gray90") +
  
  geom_line() + 
  geom_point(shape = 21) +
  
  labs(y = "Change in lean mass from pre- to post-intervention (g)") +
  
  theme_minimal() + 
  
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        panel.grid.major.x = element_blank(), 
        panel.grid.minor.y = element_blank(), 
        panel.grid.major.y = element_blank())
  
  
  
```

#### Erase redundant data ink
We have used points to represent the start and end of each line. This might be a case of redundant data ink. 

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions, reducing non-data ink with `theme_minimal` and removing redundant data ink by removing points."


delta_lean |>
  
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  
  ggplot(aes(volume, delta, 
             fill = volume, 
             group = participant)) + 
  
  geom_hline(yintercept = 0, color = "gray90") +
  
  geom_line() + 

  
  labs(y = "Change in lean mass from pre- to post-intervention (g)") +
  
  theme_minimal() + 
  
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        panel.grid.major.x = element_blank(), 
        panel.grid.minor.y = element_blank(), 
        panel.grid.major.y = element_blank())
  
  
  
```

To make the graph even more light weight we could consider making lines a bit transparent. Using `alpha = 0.5` we can add transparency to lines.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions, reducing non-data ink with `theme_minimal` and removing redundant data ink by removing points and adding transparency."


delta_lean |>
  
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  
  ggplot(aes(volume, delta, 
             fill = volume, 
             group = participant)) + 
  
  geom_hline(yintercept = 0, color = "gray90") +
  
  geom_line(alpha = 0.5) + 

  
  labs(y = "Change in lean mass from pre- to post-intervention (g)") +
  
  theme_minimal() + 
  
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        panel.grid.major.x = element_blank(), 
        panel.grid.minor.y = element_blank(), 
        panel.grid.major.y = element_blank())
  
  
  
```

#### Making comparisons

We now have a graph that represents the data, could we aid interpreting the figure? Perhaps we could add some information showing average changes per condition? Below we will construct a data frame of averages for each condition and add it to the figure.

```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions, reducing non-data ink with `theme_minimal` and removing redundant data ink by removing points and adding transparency. Adding group averages with geom_point."

descriptives <- delta_lean |>
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  summarise(.by = volume, 
            m = mean(delta))


delta_lean |>
  
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  
  ggplot(aes(volume, delta, 
             fill = volume, 
             group = participant)) + 
  
  geom_hline(yintercept = 0, color = "gray90") +
  
  
  geom_point(data = filter(descriptives, volume== "Low-volume"), # <1>
                           aes(volume, m, group = NULL, fill = NULL), 
                           position = position_nudge(x = -0.1)) +
  
    geom_point(data = filter(descriptives, volume== "Moderate-volume"), # <2>
                           aes(volume, m, group = NULL, fill = NULL), 
                           position = position_nudge(x = 0.1)) +
  
  
  
  geom_line(alpha = 0.5) + 

  
  labs(y = "Change in lean mass from pre- to post-intervention (g)") +
  
  theme_minimal() + 
  
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        panel.grid.major.x = element_blank(), 
        panel.grid.minor.y = element_blank(), 
        panel.grid.major.y = element_blank())


```

1. Two point layers are added to make it easy to plot points besides lines. Notice that the x-axis factor must be correctly formatted
2. The other point layer, here position_nudge is positive.

Again, we might not be giving the reader of the graph the full story. Recently a new type of graph has been suggested to aid interpretation of two-group comparisons. In addition to means we could add the estimate of the difference between groups. These plots are called estimation plots [@ho2019]. In our previous work we used different variations of ANCOVA models to adjust for baseline values [@hammarstrom2020] while modelling the change score. Let's start by fitting the model. Since the design is a bit tricky we need to let the model know that observations are grouped by participant. We can use the same `delta_lean` data set to fit the model. 

```{r}
#| message: false
#| warning: false

library(lme4)

mod <- lmer(delta ~ scale(pre) + volume + (1|participant), 
            data = delta_lean)

mod_results <- data.frame(cbind(coef(summary(mod)), confint(mod)[3:5, ])) # <1>

```

1. The output from the model is saved in a new object, including confidence intervals for each coefficient.

Our model gives us one coefficient of interest, `volumesingle`. This is the difference between `multiple` and `single` sets change in lean mass. This coefficient has an accompanying confidence interval that can be used for inference. Let's add the difference between groups as an additional point to the plot together with a confidence interval and a second scale. 


```{r}
#| code-fold: true
#| code-summary: "Code producing the figure"
#| fig-cap: "A line graph grouped by participant comparing conditions, reducing non-data ink with `theme_minimal` and removing redundant data ink by removing points and adding transparency. Adding group averages with geom_point."



descriptives <- delta_lean |>
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  summarise(.by = volume, 
            m = mean(delta))



# <1> 
zero <- descriptives |>
  filter(volume == "Low-volume") |>
  pull(m)

# <2>
est <- zero + (- mod_results[3,1])
ciu <- - mod_results[3,4] + zero
cil <- - mod_results[3,5] + zero



delta_lean |>
  
  mutate(volume = factor(volume, levels = c("single", "multiple"), 
                         labels = c("Low-volume", "Moderate-volume"))) |>
  
  ggplot(aes(volume, delta, 
   
             group = participant)) + 
  
    
  geom_point(data = filter(descriptives, volume== "Low-volume"), # <1>
                           aes(volume, m, group = NULL, fill = NULL), 
                           position = position_nudge(x = -0.1)) +
  
  # <3>
  geom_segment(y = zero, yend = zero, x = 0.95, xend = 2.2, color = "gray50", 
               lty = 1) +
    # <4>
    geom_errorbar(aes(y = est, ymin = cil, 
                ymax = ciu, x = 2.1), 
                width = 0, color = "gray50") +
  
  
  geom_point(data = filter(descriptives, volume== "Moderate-volume"), # <2>
                           aes(volume, m, group = NULL, fill = NULL), 
                           position = position_nudge(x = 0.1), 
             shape = 24, 
             size = 2, 
             fill = "gray60") +



  geom_line(alpha = 0.5) + 
 
  labs(y = "Change in lean mass from pre- to post-intervention (g)") +
  
  theme_minimal() + 
  
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        panel.grid.major.x = element_blank(), 
        panel.grid.minor.y = element_blank(), 
        panel.grid.major.y = element_blank())




```

1. A "zero line" is created from the descriptive data in the low-volume group
2. The confidence interval is "corrected" to the observed data as the model CI only shows the differences between groups. Notice that estimates are reversed in the model.
3. A segment is added to represent the "zero line", the mean in low-volume.
4. An errorbar is used around the descriptive data for the moderate volume group. 

The resulting graph shows the change from pre- to post-intervention in each condition per participant by lines. The average at the reference category represents a baseline to which the moderate volume condition is compared. Inference can be made from a 95% confidence interval around the moderate-volume condition. 


## Edit and revise in practice

The process of creating graphs is an iterative practice. We try something, edit and revise. When the end result goes into a publication it is a good idea to have a workflow that updates the end result not some intermediate result. 

Let us say that we are planning to submit a paper to the American Journal of Physiology. In the author instruction we read that a single column figure should be less or equal to 8.9 cm in width and a maximum 22.8 in height/depth.[^amjphys] This gives some basics instructions for our plot. 

[^amjphys]: See https://journals.physiology.org/manuscript-prep#figures

Graphs could be created from separate R scripts. This makes the workflow smoother as we only need to run a single script to recreate the output after revision. I keep my figures together with the scripts in a dedicated folder in my project folder called figures. Here I number figures and their corresponding scripts as `figure1.R`, `figure1.pdf`, `figure2.R` etc.

On the bottom of the script I have a call to the function `ggsave`. This function makes it easy to save a ggplot in a number of formats, also formats accepted by journals (such as TIF and PDF).

When I make changes to the script and saves them they are automatically sourced and the output is recreated. 


## Additional notes, tips and topics

### Labels, annotations and special texts

A package called `ggtext` makes it possible to write markdown syntax in labels and annotation in ggplots. This improves usability to a large degree as subscripts and superscrits together with special characters are easily added to labels etc. 

Sometimes custom fonts are needed. Your basic collection of fonts are not that impressive but packages such as `showtext` may help in installing additional fonts.



```{r}
#| code-fold: true
#| message: false
#| warning: false
#| code-summary: "Code producing the figure"
#| fig-cap: "Adding a silly font to a basic graph"


library(showtext)

font_add_google(name = "Permanent Marker", 
                family = "permanentmarker") # <1>
showtext_auto()


leg_leanmass |>
  filter(include != "excl") |>
  mutate(time = factor(time, 
                       levels = c("pre", "post"))) |>

ggplot(aes(time, lean_mass, fill = volume)) + 
         geom_boxplot() +
  
  labs(x = "Time", 
       y = "Leg lean\nmass (g)", 
       fill = "Volume condition", 
       title = "The plot title", 
       subtitle = "The plot subtitle", 
       caption = "the plot caption") +
  
  scale_x_discrete(labels = c("Pre\nintervention", 
                                  "Post\nintervention")) +
  
  
  theme(axis.title.x = element_blank(), 
        legend.position = "top",
        plot.title = element_text(color = "black", 
                                  family = "permanentmarker", # <2>
                                  size = 40))


```

1. This "installs" the font on your system.
2. Specifying a font family, use your own specified name to access it.




### Glamorous graphics

In a talk at RStudio conference in 2020, Will Chase presented principles related to glamorous graphics. In contrast to Tufte's principles (discussed above), glamorous graphics suggest adding ink to increase the attractiveness of graphics. (This might be a topic for a later workshop).

<!-- 
Why glamorous graphics? - Engage a wider audience - Aesthetics matters for understanding - "respecting the audience"

The glamour of graphics uses color, typography and layout to increase the impact of the graphic.

### Layout

#### Alignment

Top left align titles

Text should be horizontal

Axis labels should also be horizontal

Alignment should provide clean lines and symmetry

Some alignment can be left/center/right to provide overall structure to the graph.

#### Border, Grid lines, legends

Do not use borders or grid lines. If grid lines, make them lighter and more subtle.

Avoid legends, labels of the data are better or titles with color.

#### White space

Use white space to separate elements of the graph and give the reader room to understand the graph.

### Typography

#### Fonts

#### Hierarchy

This gives the reader a hierarchy of information.

### Color

What colors look good together?

```{r}

# Load required libraries
library(ggplot2)

# Create a data frame of angles and radii
angles <- seq(0, 360, by = 0.1)
radii <- seq(0.1, 1, by = 0.1)  # Vary the starting point to avoid a point at the center
df <- expand.grid(angle = angles, radius = radii)

# Create ggplot of colored points in polar coordinates
p <- ggplot(df, aes(x = angle, y = radius, color = angle, alpha = radius)) +
  geom_point(size = 8) +
  scale_color_gradientn(colors = rainbow(360)) +
  scale_alpha_continuous(range = c(1, 0.1)) +
  coord_polar(theta = "x") +
  theme_void() +
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none")
  

#### Alternative

# Create a data frame of angles from 0 to 360
angles <- seq(0, 360, by = 0.2)
df <- data.frame(angle = angles)

# Create ggplot of colored points in polar coordinates
p <- ggplot(df, aes(x = angle, y = 1, color = angle)) +
  geom_point(size = 10) +
  scale_color_gradientn(colors = rainbow(360)) +
  coord_polar(theta = "x") +
  theme_void() +
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none")

```

The color wheel can be used to find

-   Complementary colors that will give high contrast
-   Monochromatic will give harmonious\
-   Analogous are choosen from the same side on the color wheele colors to avoid contrast but still enable showing differences
-   Triadic colors to give more

 https://www.canva.com/colors/color-wheel/ for more on this 

#### Describing colors, Hue, Saturation and Lightness

#### Background colors

Colors can help reduce "hardness" by avoiding a white background.-->
