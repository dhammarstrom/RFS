[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Scientific Visualization, Collaboration and Thinking",
    "section": "",
    "text": "Preface\nThe purpose of this collection of workshops is to provide basic skills and understanding of scientific visualization, collaboration, and thinking. These concepts are often not taught explicitly in postgraduate courses. Instead, they are assumed to be known and understood or somehow magically infused in students through their respective scientific environments. Instead of relying on magic, professional skills should be taught and developed continuously, explicitly, and systematically.\nThe first workshop deals with data visualization which is a fundamental skill for any scientist. Data visualization, like writing, serves multiple purposes in day-to-day scientific practice. Making graphs before data collection can help the researcher better formulate the scientific problem or explain core concepts for oneself, committees or funding agencies. Visualizations will also be important for exploratory data analysis, for discovering problematic data formatting or important patterns related to the scientific problem. Lastly, visualizations will aid in communicating scientific results to other researchers and the public.\nTwo workshops are devoted to collaboration in data-intensive science. The first workshop deals with the basics of version control and the second workshop deals with structuring collected data into data packages for analysis and sharing. Version control is a way to keep track of changes in a set of files. It also provides opportunities for effective collaboration in complex projects. Using the R package system for data management and sharing is a way to ensure that data is well documented and downstream analyses are reproducible.\nThe last workshop deals with how we can develop scientific thinking using scientific models and data simulations. We will use graphical models to draw out assumptions and explore simulations as a way to test the robustness of our models and plan experiments."
  },
  {
    "objectID": "data-viz.html#a-grammar-of-graphics---ggplot2",
    "href": "data-viz.html#a-grammar-of-graphics---ggplot2",
    "title": "1  Data visualization",
    "section": "1.1 A grammar of graphics - ggplot2",
    "text": "1.1 A grammar of graphics - ggplot2\nBuilding on Wilkinsons The Grammar of Graphics (Wilkinson and Wills 2005), Wickham (Wickham 2010, 2016) implemented a graphical grammar to R through the package ggplot2. The idea behind both Wickhams and Wilkinsons formalized syntax for creating data visualizations is to avoid special cases or duplicate methods and allow for creation of data visualizations based on a set of core components used in all graphics (Wickham 2010; Wilkinson and Wills 2005).\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of Graphics. 2nd ed. Statistics and Computing. New York: Springer.\n\n———. 2016. Ggplot2 : Elegant Graphics for Data Analysis. 2nd ed. Use r! Cham: Springer International Publishing : Imprint: Springer. https://doi.org/10.1007/978-3-319-24277-4.\nThe grammar (in the version described by Wickham (Wickham 2010)) has seven components that together creates a ggplot2 visualization (Figure 1.1).\nThe underlying data contains the variables that are mapped to aesthetics such as coordinates, colors or shapes. Each aesthetic can be controlled through scales by assigning values to coordinates, colors, shapes etc. Geometric objects creates the visual representations of the mapping. Sometimes small multiples of the same graph are created using facets which creates subdivision of the data to be plotted in different panels. Statistical transformations creates summaries of the data, however, in its simplest form, the transformation is the identity transformation. All graphical representations are plotted in a coordinate system. Theme and annotations adds non-data layers to the plot which can include geometric shapes or text (Figure 1.1).\n\n\n\n\n\nFigure 1.1: Components of a ggplot2 visualization\n\n\n\n\n\n1.1.1 Building blocks of a plot\nUsing a similar example as in (Wickham 2010) a basic plot can be broken down into the data (see Table 1.1), geometric objects, scales and coordinates and annotations. These components, that can be individually manipulated, together creates the final plot (see Figure 1.2 a-d).\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics 19 (1): 3–28. https://doi.org/10.1198/jcgs.2009.07098.\n\n\n\n\n\n\nTable 1.1:  Example data for a ggplot \n  \n    \n    \n      x\n      y\n      shape\n    \n  \n  \n    1.0\n3.0\na\n    2.4\n2.0\na\n    4.0\n5.0\nb\n    5.2\n7.8\nb\n  \n  \n  \n\n\n\n\n\n\n\n\n\n\nFigure 1.2: Three components, geometric objects (a), coordinates and scales (b) and plot annotations (c) are constitues of the complete plot (d)\n\n\n\n\nThe corresponding code to create this plot is fairly straight forward:\n\nlibrary(ggplot2)\n\n1df &lt;- data.frame(x = c(1, 2.4, 4, 5.2),\n           y = c(3, 2, 5, 7.8), \n           shape = c(\"a\", \"a\", \"b\", \"b\")) \n\n\n2  ggplot(data = df,\n3         mapping = aes(x = x, y = y, shape = shape))  +\n\n4  geom_point(color = \"black\", size = 3) +\n  \n5    labs(title = \"Title\",\n       subtitle = \"Subtitle\", \n       x = \"x-axis\", \n       y = \"y-axis\", \n       shape = \"legend\") +\n6    theme_classic()\n\n\n1\n\nA simple data frame is saved containing the variables we will plot\n\n2\n\nThe data is explicitly called\n\n3\n\nVariables are mapped to coordinates (x and y) and shapes.\n\n4\n\nGeometric objects (points) are specified with color and size determined in the function\n\n5\n\nAnnotations are added to the plot through the labs (labels) function.\n\n6\n\nA pre-built theme is used to change the default appearance of the plot."
  },
  {
    "objectID": "data-viz.html#before-plotting",
    "href": "data-viz.html#before-plotting",
    "title": "1  Data visualization",
    "section": "1.2 Before plotting",
    "text": "1.2 Before plotting\nAs we saw above, a basic visualization can be created from a data set, or a data frame which is the most common representation of data in R. A tidy data set has one observation per row and one variable per column. A tidy data set makes data visualization easy. However, not all data sets are friendly. In fact, some might be unfriendly because they are unhappy1.1 The reference to happiness is a reference to Wickham (2014) wherein Tolstoy’s Anna Karenina is quoted; “Happy families are all alike; every unhappy family is unhappy in its own way.” The Anna Karenina principle applies to data as non-tidy data can be non-tidy in many ways, tidy data however are tidy because they all share a common set of features.\n———. 2014. “Tidy Data.” Journal of Statistical Software; Vol 1, Issue 10 (2014), September. https://www.jstatsoft.org/v059/i10 http://dx.doi.org/10.18637/jss.v059.i10.\n\n\n\n\nA lot of effort goes into making data sets suitable for visualization or statistical modelling. The good news is that R is especially suited for the process of importing and wrangling data. As with other common tasks in R there are numerous ways of achieving the same goals. This is a good thing because it allows for solutions to a wide range of problems. It is also a bad thing because it makes it difficult to getting started. A collection of R packages called the Tidyverse makes the process of getting started with data wrangling easier.\nTidyverse can be thought of as a dialect of the R language. The dialect is designed to make it easy to write sequential operations in a way that translates thoughts and ideas to code. Sequential operations are enabled by a pipe operator. Using a pipe operator we can call functions in sequential order to do specific operations on the data. We can write such a pipe as demonstrated below with the corresponding English language descriptions to the left.\n\n\nTake the data then do filter the data based on x larger than 10 then do add a new calculated variable z = x + y then do show the output\n\n\ndata |&gt;\n  filter(x &gt; 10) |&gt;\n  mutate(z = x + y) |&gt;\n  print()\n\n\n\nThe pipe operator (|&gt;) takes any input and place it as the first argument in the following function2. This is the mechanism that makes sequential operations possible. A pipe operator makes code more readable, consider the following two alternatives:2 A function is a basic building block of your R code. Function are designed for specific tasks and can be part of packages or created by the user. A function may take arguments such as fun(&lt;ARGUMENT1&gt; = &lt;default input&gt;, &lt;ARGUMNET2&gt; = &lt;default input&gt;). Arguments can be used without explicitly naming them by putting expected input in at the right position. Orders of argument may be changed is argument names are used.\n\n\n\n\n1print(mutate(filter(select(data, var1:var3), var1 == \"xxx\"), var4 = var1 + var2))\n\n\n2data |&gt;\n  select(var1:var3) |&gt;\n  filter(var1 == \"xxx\") |&gt;\n  mutate(var4 = var1 + var2) \n\n\n1\n\nAlternative 1: A number of operations are performed on data, we have to read from in to out to see each step.\n\n2\n\nAlternative 2: The same steps are performed as in alternative 1, in the same order.\n\n\n\n\nThe pipe in alternative 2 are structured with the pipe operator making the code more readable and easier to edit. Notice that the same functions are used in both cases.\nIn R there are two main pipe operators. We have the “base R” pipe, |&gt;. This pipe operator is included in the base installation of R and available without loading any packages on start up. A second pipe belongs to the magritter package. The magritter pipe (%&gt;%) has the same basic functionality as the base pipe; the left hand input is inserted as the first argument in any right hand function.\nSometimes you might want to place your input somewhere else than as the first argument in a right hand function. A placeholder can be used to indicate where you would like to place your input. The base pipe differs from the magritter pipe in what symbol indicates a placeholder. In the example below, the function some_fun() expects data as the third argument. We need to use our placeholder to put the data in the correct position:\n\n1data |&gt;\n  some_fun(arg1 = c(1, 2), \n           arg2 = \"some.setting\", \n           arg3 = _)\n\n\nlibrary(tidyverse)\n2data %&gt;%\n  some_fun(arg1 = c(1, 2), \n           arg2 = \"some.setting\", \n           arg3 = .)\n\n\n1\n\nWith the base R forward pipe operator.\n\n2\n\nWith the magritter forward pipe operator.\n\n\n\n\n\n1.2.1 Reading data into R\nThree packages makes reading tabular data into R easy. readr provides functions for reading and writing delimiter separated files, such as .csv or .tsv. readxl provides functions that imports data from excel files. An finally, googlesheets4 makes it possible to read tabular data created in google sheets.\nData can also be loaded from packages in R since storing data is a convenient way of sharing. By including data in a package you are nudged to do some quality checks and document it. We will talk more about data packages in a later workshop.\n\n\n1.2.2 The verbs of data wrangling\nOnce data is available in our workspace we will be able to wrangle it. In the examples below I will use a data set containing results from dual x-ray absorptiometry measurements available in the exscidata package. To install the exscidata package:\n\nlibrary(remotes)\ninstall_github(\"dhammarstrom/exscidata\")\n\nThe dplyrpackage provides a collection of verbs to facilitate wrangling. As mentioned above, “pipeable” functions takes a data frame as its first argument. This means that we can line up functions in sequential order using a pipe operator. In all verb functions, following the data argument follows a set of arguments that specifies what we wish to do with the data. The result of the operations performed by the function are returned as a data frame.\ndplyr contains the following main data verbs:\n\nselect\nrename\nrelocate\nmutate\nfilter\narrange\nsummarize\n\nIn addition, several helper function will aid our wrangling endeavors.\ndplyr is loaded as part of the tidyverse package:\n\nlibrary(tidyverse)\n\n\n1.2.2.1 Select, rename and relocate variables\nVariables in a data frame may be selected and renamed. Such operation may have multiple purposes such as giving you a better overview of the data of interest or limiting what data to display in a table. Renaming can make life easier if the data set contains long variable names.\nBelow we will store a subset of the data in a new data set. But we will first have a look at what column names are available:\n\n1library(exscidata)\n2glimpse(exscidata::dxadata)\n\n\n1\n\nLoading the exscidata package\n\n2\n\nUsing glimbse we will get a overview of all available variables in the data set. The double :: means that we are looking for the data set dxadata inside the package exscidata.\n\n\n\n\nRows: 80\nColumns: 59\n$ participant      &lt;chr&gt; \"FP28\", \"FP40\", \"FP21\", \"FP34\", \"FP23\", \"FP26\", \"FP36…\n$ time             &lt;chr&gt; \"pre\", \"pre\", \"pre\", \"pre\", \"pre\", \"pre\", \"pre\", \"pre…\n$ multiple         &lt;chr&gt; \"L\", \"R\", \"R\", \"R\", \"R\", \"R\", \"L\", \"R\", \"R\", \"L\", \"L\"…\n$ single           &lt;chr&gt; \"R\", \"L\", \"L\", \"L\", \"L\", \"L\", \"R\", \"L\", \"L\", \"R\", \"R\"…\n$ sex              &lt;chr&gt; \"female\", \"female\", \"male\", \"female\", \"male\", \"female…\n$ include          &lt;chr&gt; \"incl\", \"incl\", \"incl\", \"incl\", \"incl\", \"excl\", \"incl…\n$ age              &lt;dbl&gt; 24.5, 22.1, 26.8, 23.1, 24.8, 24.2, 20.5, 20.6, 37.4,…\n$ height           &lt;dbl&gt; 170.0, 175.0, 184.0, 164.0, 176.5, 163.0, 158.0, 181.…\n$ weight           &lt;dbl&gt; 66.5, 64.0, 85.0, 53.0, 68.5, 56.0, 60.5, 83.5, 65.0,…\n$ BMD.head         &lt;dbl&gt; 2.477, 1.916, 2.306, 2.163, 2.108, 2.866, 1.849, 2.21…\n$ BMD.arms         &lt;dbl&gt; 0.952, 0.815, 0.980, 0.876, 0.917, 0.973, 0.871, 0.91…\n$ BMD.legs         &lt;dbl&gt; 1.430, 1.218, 1.598, 1.256, 1.402, 1.488, 1.372, 1.42…\n$ BMD.body         &lt;dbl&gt; 1.044, 0.860, 1.060, 0.842, 0.925, 0.984, 0.923, 1.01…\n$ BMD.ribs         &lt;dbl&gt; 0.770, 0.630, 0.765, 0.636, 0.721, 0.737, 0.648, 0.70…\n$ BMD.pelvis       &lt;dbl&gt; 1.252, 1.078, 1.314, 1.044, 1.154, 1.221, 1.194, 1.32…\n$ BMD.spine        &lt;dbl&gt; 1.316, 0.979, 1.293, 0.899, 1.047, 1.089, 1.006, 1.14…\n$ BMD.whole        &lt;dbl&gt; 1.268, 1.082, 1.325, 1.119, 1.181, 1.350, 1.166, 1.24…\n$ fat.left_arm     &lt;dbl&gt; 1168, 715, 871, 610, 788, 372, 932, 1312, 388, 668, 5…\n$ fat.left_leg     &lt;dbl&gt; 4469, 4696, 3467, 3023, 3088, 2100, 4674, 5435, 1873,…\n$ fat.left_body    &lt;dbl&gt; 6280, 4061, 7740, 3638, 6018, 2328, 4896, 9352, 2921,…\n$ fat.left_whole   &lt;dbl&gt; 12365, 9846, 12518, 7565, 10259, 5048, 10736, 16499, …\n$ fat.right_arm    &lt;dbl&gt; 1205, 769, 871, 610, 741, 374, 940, 1292, 413, 716, 5…\n$ fat.right_leg    &lt;dbl&gt; 4497, 4900, 3444, 3017, 3254, 2082, 4756, 5455, 1782,…\n$ fat.right_body   &lt;dbl&gt; 6082, 3923, 8172, 3602, 5699, 2144, 4705, 8674, 2640,…\n$ fat.right_whole  &lt;dbl&gt; 12102, 9862, 12856, 7479, 10020, 4821, 10806, 15876, …\n$ fat.arms         &lt;dbl&gt; 2373, 1484, 1742, 1220, 1529, 747, 1872, 2604, 802, 1…\n$ fat.legs         &lt;dbl&gt; 8965, 9596, 6911, 6040, 6342, 4182, 9430, 10890, 3655…\n$ fat.body         &lt;dbl&gt; 12362, 7984, 15912, 7239, 11717, 4472, 9601, 18026, 5…\n$ fat.android      &lt;dbl&gt; 1880, 963, 2460, 1203, 1933, 527, 1663, 3183, 1240, 1…\n$ fat.gynoid       &lt;dbl&gt; 5064, 5032, 4779, 3739, 4087, 2740, 5217, 6278, 2309,…\n$ fat.whole        &lt;dbl&gt; 24467, 19708, 25374, 15044, 20278, 9869, 21542, 32375…\n$ lean.left_arm    &lt;dbl&gt; 1987, 1931, 2884, 1753, 2652, 2425, 1913, 2266, 3066,…\n$ lean.left_leg    &lt;dbl&gt; 7059, 7190, 10281, 6014, 8242, 7903, 6829, 8889, 9664…\n$ lean.left_body   &lt;dbl&gt; 9516, 10693, 13847, 9736, 11387, 10573, 8954, 11482, …\n$ lean.left_whole  &lt;dbl&gt; 20305, 21778, 29332, 19143, 24185, 22946, 18809, 2431…\n$ lean.right_arm   &lt;dbl&gt; 2049, 2081, 2888, 1754, 2487, 2439, 1930, 2236, 3253,…\n$ lean.right_leg   &lt;dbl&gt; 7104, 7506, 10200, 6009, 8685, 7841, 6950, 8923, 9198…\n$ lean.right_body  &lt;dbl&gt; 9199, 10304, 14593, 9636, 10779, 9733, 8602, 10672, 1…\n$ lean.right_whole &lt;dbl&gt; 19605, 21310, 29643, 18792, 23653, 21837, 19407, 2372…\n$ lean.arms        &lt;dbl&gt; 4036, 4012, 5773, 3508, 5139, 4864, 3843, 4501, 6319,…\n$ lean.legs        &lt;dbl&gt; 14163, 14696, 20482, 12023, 16928, 15744, 13779, 1781…\n$ lean.body        &lt;dbl&gt; 18715, 20998, 28440, 19372, 22166, 20306, 17556, 2215…\n$ lean.android     &lt;dbl&gt; 2669, 2782, 3810, 2455, 2904, 2656, 2297, 3094, 3344,…\n$ lean.gynoid      &lt;dbl&gt; 6219, 7209, 10233, 5866, 7525, 5970, 5825, 8175, 7760…\n$ lean.whole       &lt;dbl&gt; 39910, 43088, 58976, 37934, 47837, 44783, 38216, 4804…\n$ BMC.left_arm     &lt;dbl&gt; 181, 138, 204, 144, 180, 173, 140, 173, 220, 226, 225…\n$ BMC.left_leg     &lt;dbl&gt; 567, 508, 728, 441, 562, 574, 482, 631, 633, 630, 672…\n$ BMC.left_body    &lt;dbl&gt; 622, 414, 696, 367, 526, 465, 370, 629, 473, 629, 509…\n$ BMC.left_whole   &lt;dbl&gt; 1680, 1321, 1945, 1201, 1527, 1580, 1131, 1688, 1544,…\n$ BMC.right_arm    &lt;dbl&gt; 198, 150, 210, 142, 176, 183, 140, 176, 224, 251, 226…\n$ BMC.right_leg    &lt;dbl&gt; 574, 514, 739, 431, 552, 565, 491, 641, 622, 636, 690…\n$ BMC.right_body   &lt;dbl&gt; 592, 428, 730, 351, 502, 409, 358, 582, 420, 616, 483…\n$ BMC.right_whole  &lt;dbl&gt; 1582, 1288, 1958, 1130, 1451, 1466, 1229, 1668, 1478,…\n$ BMC.arms         &lt;dbl&gt; 379, 288, 414, 285, 356, 357, 280, 348, 444, 478, 451…\n$ BMC.legs         &lt;dbl&gt; 1142, 1022, 1467, 872, 1115, 1139, 974, 1272, 1255, 1…\n$ BMC.body         &lt;dbl&gt; 1214, 842, 1426, 718, 1028, 874, 728, 1211, 893, 1245…\n$ BMC.android      &lt;dbl&gt; 80, 57, 90, 44, 56, 54, 43, 77, 52, 72, 59, 60, 65, 5…\n$ BMC.gynoid       &lt;dbl&gt; 314, 285, 427, 245, 299, 262, 241, 379, 335, 378, 332…\n$ BMC.whole        &lt;dbl&gt; 3261, 2609, 3903, 2331, 2978, 3046, 2360, 3356, 3022,…\n\n\nThe data set contains 80 rows and 59 columns. The variables in the data set are described as part of the exscidata package and can be seen by typing ?dxadata in the console.\nWe will work further with lean body mass data, these are variables starting with lean.. In addition we need variables describing observations like participant, time, multiple, single, sex, include, height and weight. To select these variables we can try a couple of different approaches. The select function can select variables by name. This means that we can simply list them:\n\n1exscidata::dxadata |&gt;\n2  select(participant, time, multiple, single) |&gt;\n3  print()\n\n\n1\n\nRetrieve the data from the exscidata package\n\n2\n\nselect variables based on names\n\n3\n\nPrint the resulting data frame.\n\n\n\n\n# A tibble: 80 × 4\n   participant time  multiple single\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; \n 1 FP28        pre   L        R     \n 2 FP40        pre   R        L     \n 3 FP21        pre   R        L     \n 4 FP34        pre   R        L     \n 5 FP23        pre   R        L     \n 6 FP26        pre   R        L     \n 7 FP36        pre   L        R     \n 8 FP38        pre   R        L     \n 9 FP25        pre   R        L     \n10 FP19        pre   L        R     \n# ℹ 70 more rows\n\n\nThe above approach means a lot of work writing all columns names in the select call. An alternative approach is to select variables based on the first and last variable in a sequence. This is possible by using the syntax &lt;first column&gt;:&lt;last column&gt;.\n\nexscidata::dxadata |&gt;  \n1  select(participant:weight) |&gt;\n  print() \n\n\n1\n\nSelecting by the first and last column in a sequence.\n\n\n\n\n# A tibble: 80 × 9\n   participant time  multiple single sex    include   age height weight\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female incl     24.5   170    66.5\n 2 FP40        pre   R        L      female incl     22.1   175    64  \n 3 FP21        pre   R        L      male   incl     26.8   184    85  \n 4 FP34        pre   R        L      female incl     23.1   164    53  \n 5 FP23        pre   R        L      male   incl     24.8   176.   68.5\n 6 FP26        pre   R        L      female excl     24.2   163    56  \n 7 FP36        pre   L        R      female incl     20.5   158    60.5\n 8 FP38        pre   R        L      female incl     20.6   181    83.5\n 9 FP25        pre   R        L      male   incl     37.4   183    65  \n10 FP19        pre   L        R      male   incl     22.3   178.   73.5\n# ℹ 70 more rows\n\n\nWe also like to have the lean body mass data included in our new data set. Since all variables containing lean body mass data starts with lean. we can use a helper function to select them. Two alternatives are possible:\n\nexscidata::dxadata |&gt;  \n1  select(participant:weight, starts_with(\"lean.\")) |&gt;\n  print() \n\n\nexscidata::dxadata |&gt;  \n2  select(participant:weight, contains(\"lean.\")) |&gt;\n  print() \n\n\n1\n\nUsing starts_with to select all columns that starts with lean.\n\n2\n\nUsing containsto select all variables that contains lean.\n\n\n\n\n# A tibble: 80 × 23\n   participant time  multiple single sex    include   age height weight\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female incl     24.5   170    66.5\n 2 FP40        pre   R        L      female incl     22.1   175    64  \n 3 FP21        pre   R        L      male   incl     26.8   184    85  \n 4 FP34        pre   R        L      female incl     23.1   164    53  \n 5 FP23        pre   R        L      male   incl     24.8   176.   68.5\n 6 FP26        pre   R        L      female excl     24.2   163    56  \n 7 FP36        pre   L        R      female incl     20.5   158    60.5\n 8 FP38        pre   R        L      female incl     20.6   181    83.5\n 9 FP25        pre   R        L      male   incl     37.4   183    65  \n10 FP19        pre   L        R      male   incl     22.3   178.   73.5\n# ℹ 70 more rows\n# ℹ 14 more variables: lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;, lean.whole &lt;dbl&gt;\n# A tibble: 80 × 23\n   participant time  multiple single sex    include   age height weight\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female incl     24.5   170    66.5\n 2 FP40        pre   R        L      female incl     22.1   175    64  \n 3 FP21        pre   R        L      male   incl     26.8   184    85  \n 4 FP34        pre   R        L      female incl     23.1   164    53  \n 5 FP23        pre   R        L      male   incl     24.8   176.   68.5\n 6 FP26        pre   R        L      female excl     24.2   163    56  \n 7 FP36        pre   L        R      female incl     20.5   158    60.5\n 8 FP38        pre   R        L      female incl     20.6   181    83.5\n 9 FP25        pre   R        L      male   incl     37.4   183    65  \n10 FP19        pre   L        R      male   incl     22.3   178.   73.5\n# ℹ 70 more rows\n# ℹ 14 more variables: lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;, lean.whole &lt;dbl&gt;\n\n\nThere are other select helper functions such as ends_with and matches that work in a similar fashion as the above. all_of and any_of helps you select variables based on a vector of variables, where selects based on where a function of your choosing returns true. See ?select for a complete list.\nIn a select call we can also rename variables using the syntax &lt;new name&gt; = &lt;old name&gt;. Let’s say we want to select and rename participant:\n\nexscidata::dxadata |&gt;  \n  select(parti = participant, time:weight, starts_with(\"lean.\")) |&gt; \n  print() \n\n# A tibble: 80 × 23\n   parti time  multiple single sex    include   age height weight lean.left_arm\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1 FP28  pre   L        R      female incl     24.5   170    66.5          1987\n 2 FP40  pre   R        L      female incl     22.1   175    64            1931\n 3 FP21  pre   R        L      male   incl     26.8   184    85            2884\n 4 FP34  pre   R        L      female incl     23.1   164    53            1753\n 5 FP23  pre   R        L      male   incl     24.8   176.   68.5          2652\n 6 FP26  pre   R        L      female excl     24.2   163    56            2425\n 7 FP36  pre   L        R      female incl     20.5   158    60.5          1913\n 8 FP38  pre   R        L      female incl     20.6   181    83.5          2266\n 9 FP25  pre   R        L      male   incl     37.4   183    65            3066\n10 FP19  pre   L        R      male   incl     22.3   178.   73.5          3760\n# ℹ 70 more rows\n# ℹ 13 more variables: lean.left_leg &lt;dbl&gt;, lean.left_body &lt;dbl&gt;,\n#   lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;, lean.right_leg &lt;dbl&gt;,\n#   lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;, lean.arms &lt;dbl&gt;,\n#   lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;, lean.gynoid &lt;dbl&gt;,\n#   lean.whole &lt;dbl&gt;\n\n\nNotice how different ways of selecting variables can be combined in select.\nThe rename function makes it easy to rename variables without the need to select.\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  rename(parti = participant) |&gt;\n  print() \n\n# A tibble: 80 × 23\n   parti time  multiple single sex    include   age height weight lean.left_arm\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1 FP28  pre   L        R      female incl     24.5   170    66.5          1987\n 2 FP40  pre   R        L      female incl     22.1   175    64            1931\n 3 FP21  pre   R        L      male   incl     26.8   184    85            2884\n 4 FP34  pre   R        L      female incl     23.1   164    53            1753\n 5 FP23  pre   R        L      male   incl     24.8   176.   68.5          2652\n 6 FP26  pre   R        L      female excl     24.2   163    56            2425\n 7 FP36  pre   L        R      female incl     20.5   158    60.5          1913\n 8 FP38  pre   R        L      female incl     20.6   181    83.5          2266\n 9 FP25  pre   R        L      male   incl     37.4   183    65            3066\n10 FP19  pre   L        R      male   incl     22.3   178.   73.5          3760\n# ℹ 70 more rows\n# ℹ 13 more variables: lean.left_leg &lt;dbl&gt;, lean.left_body &lt;dbl&gt;,\n#   lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;, lean.right_leg &lt;dbl&gt;,\n#   lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;, lean.arms &lt;dbl&gt;,\n#   lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;, lean.gynoid &lt;dbl&gt;,\n#   lean.whole &lt;dbl&gt;\n\n\nIf we want to change the order of variables in a data set we can specify the order in a select call, or use relocate\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  relocate(lean.whole) |&gt;\n  print() \n\n# A tibble: 80 × 23\n   lean.whole participant time  multiple single sex    include   age height\n        &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1      39910 FP28        pre   L        R      female incl     24.5   170 \n 2      43088 FP40        pre   R        L      female incl     22.1   175 \n 3      58976 FP21        pre   R        L      male   incl     26.8   184 \n 4      37934 FP34        pre   R        L      female incl     23.1   164 \n 5      47837 FP23        pre   R        L      male   incl     24.8   176.\n 6      44783 FP26        pre   R        L      female excl     24.2   163 \n 7      38216 FP36        pre   L        R      female incl     20.5   158 \n 8      48045 FP38        pre   R        L      female incl     20.6   181 \n 9      54710 FP25        pre   R        L      male   incl     37.4   183 \n10      58740 FP19        pre   L        R      male   incl     22.3   178.\n# ℹ 70 more rows\n# ℹ 14 more variables: weight &lt;dbl&gt;, lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;\n\n\nrelocate puts the selected variable as the first column in the data set. If we want to specify the location we can use the arguments .before or .after.\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  relocate(lean.whole, .after = sex) |&gt;\n  print() \n\n# A tibble: 80 × 23\n   participant time  multiple single sex    lean.whole include   age height\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female      39910 incl     24.5   170 \n 2 FP40        pre   R        L      female      43088 incl     22.1   175 \n 3 FP21        pre   R        L      male        58976 incl     26.8   184 \n 4 FP34        pre   R        L      female      37934 incl     23.1   164 \n 5 FP23        pre   R        L      male        47837 incl     24.8   176.\n 6 FP26        pre   R        L      female      44783 excl     24.2   163 \n 7 FP36        pre   L        R      female      38216 incl     20.5   158 \n 8 FP38        pre   R        L      female      48045 incl     20.6   181 \n 9 FP25        pre   R        L      male        54710 incl     37.4   183 \n10 FP19        pre   L        R      male        58740 incl     22.3   178.\n# ℹ 70 more rows\n# ℹ 14 more variables: weight &lt;dbl&gt;, lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;\n\n\n\n\n1.2.2.2 Creating new variables\nmutate let’s us create new variables in a data set. These can be a function of variables already in the data set or created from our input.\nLet’s create a variable representing the percentage of lean mass to body mass.\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  mutate(rel_lean_whole = 100 * ((lean.whole/1000) / weight)) |&gt;\n  relocate(rel_lean_whole) |&gt;\n  print() \n\n# A tibble: 80 × 24\n   rel_lean_whole participant time  multiple single sex    include   age height\n            &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1           60.0 FP28        pre   L        R      female incl     24.5   170 \n 2           67.3 FP40        pre   R        L      female incl     22.1   175 \n 3           69.4 FP21        pre   R        L      male   incl     26.8   184 \n 4           71.6 FP34        pre   R        L      female incl     23.1   164 \n 5           69.8 FP23        pre   R        L      male   incl     24.8   176.\n 6           80.0 FP26        pre   R        L      female excl     24.2   163 \n 7           63.2 FP36        pre   L        R      female incl     20.5   158 \n 8           57.5 FP38        pre   R        L      female incl     20.6   181 \n 9           84.2 FP25        pre   R        L      male   incl     37.4   183 \n10           79.9 FP19        pre   L        R      male   incl     22.3   178.\n# ℹ 70 more rows\n# ℹ 15 more variables: weight &lt;dbl&gt;, lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;, lean.whole &lt;dbl&gt;\n\n\n\n\n\n1.2.3 From wide to long and back again\nThe dxadata data set is not a tidy data set. It contains two variables (single and multiple) that indicates which leg has been training with low and moderate volume respectively (Hammarström et al. 2020). Additionally, lean mass variables could be separated based on body half (right or left). To compare training volume we need to reformat the data set. We will start by making a smaller data set that indicate training volume per leg.\nAs we have already seen, participant, single and multiple are the variables needed to make a data set that indicates training volume per leg, per participant. We will start by selecting these columns followed by pivoting the data as the volume data is located in two variables. This essentially means that we will make the data set longer.\n\nexscidata::dxadata |&gt;  \n1  select(participant, multiple, single) |&gt;\n2  pivot_longer(values_to = \"leg\", names_to = \"volume\",  cols = multiple:single) %&gt;%\n  print()\n\n\n1\n\nSelecting our variables of interest\n\n2\n\nCreating a long data set based on volume data spread over two columns.\n\n\n\n\n# A tibble: 160 × 3\n   participant volume   leg  \n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;\n 1 FP28        multiple L    \n 2 FP28        single   R    \n 3 FP40        multiple R    \n 4 FP40        single   L    \n 5 FP21        multiple R    \n 6 FP21        single   L    \n 7 FP34        multiple R    \n 8 FP34        single   L    \n 9 FP23        multiple R    \n10 FP23        single   L    \n# ℹ 150 more rows\n\n\nAs we see we now have a long data set, but it is longer than expected. The original data contains only 41 participants. As each participant has two legs we would expect 82 observations. Above we did not remove post-intervention observations and we therefore have several duplicates. This can be taken care of by using the distinct function which returns unique observations across a combination of variables.\n\nparticipant_volume &lt;- exscidata::dxadata |&gt;  \n  select(participant, multiple, single) |&gt; # \n  pivot_longer(values_to = \"leg\", names_to = \"volume\",  cols = multiple:single) %&gt;%\n1  distinct(participant, volume, leg) %&gt;%\n  print()\n\n\n1\n\nRemoves all duplicate combinations of participant, volume and leg.\n\n\n\n\n# A tibble: 82 × 3\n   participant volume   leg  \n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;\n 1 FP28        multiple L    \n 2 FP28        single   R    \n 3 FP40        multiple R    \n 4 FP40        single   L    \n 5 FP21        multiple R    \n 6 FP21        single   L    \n 7 FP34        multiple R    \n 8 FP34        single   L    \n 9 FP23        multiple R    \n10 FP23        single   L    \n# ℹ 72 more rows\n\n\nWe can save our smaller data set as participant_volume\nNext we want to create a data set of right and left leg lean mass data. We will start by selecting variables.\n\nexscidata::dxadata |&gt;  \n  select(participant, time, starts_with(\"lean.\") & ends_with(\"_leg\")) |&gt; #\n  print()\n\n# A tibble: 80 × 4\n   participant time  lean.left_leg lean.right_leg\n   &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt;          &lt;dbl&gt;\n 1 FP28        pre            7059           7104\n 2 FP40        pre            7190           7506\n 3 FP21        pre           10281          10200\n 4 FP34        pre            6014           6009\n 5 FP23        pre            8242           8685\n 6 FP26        pre            7903           7841\n 7 FP36        pre            6829           6950\n 8 FP38        pre            8889           8923\n 9 FP25        pre            9664           9198\n10 FP19        pre            9704           9806\n# ℹ 70 more rows\n\n\nNotice how & was used to create a conditional selection of variables. I addition to selecting time, include3 and participant we select variables that starts with lean. AND ends with _leg.3 The variable incl is used to indicate which participants to include in a final analysis. Included participants completed a given set of training sessions.\n\n\n\nThe resulting data set is wide. Two variables contains the same variable (lean mass), but one variable (leg) is lurking in two variables (lean.left_leg and lean.right_leg). Let’s make the data set long.\n\n3leg_leanmass &lt;- exscidata::dxadata |&gt;\n  select(participant, time, include, starts_with(\"lean.\") & ends_with(\"_leg\")) |&gt; \n1  pivot_longer(names_to = \"leg\", values_to = \"lean_mass\", cols = contains(\"lean.\")) |&gt;\n2  mutate(leg = if_else(leg == \"lean.left_leg\", \"L\", \"R\")) |&gt;\n  \n  print()\n\n\n1\n\nNotice how select helpers can be used in pivot_longer.\n\n2\n\nWe use mutate together with if_else to change the leg indicator to R and L\n\n3\n\nWe save the data set as leg_leanmass\n\n\n\n\n# A tibble: 160 × 5\n   participant time  include leg   lean_mass\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;\n 1 FP28        pre   incl    L          7059\n 2 FP28        pre   incl    R          7104\n 3 FP40        pre   incl    L          7190\n 4 FP40        pre   incl    R          7506\n 5 FP21        pre   incl    L         10281\n 6 FP21        pre   incl    R         10200\n 7 FP34        pre   incl    L          6014\n 8 FP34        pre   incl    R          6009\n 9 FP23        pre   incl    L          8242\n10 FP23        pre   incl    R          8685\n# ℹ 150 more rows\n\n\npivot_longer has a brother called pivot_wider, this functions performs the reverse operation making long data sets wide. Let’s say that we would like to calculate the paired difference of leg lean mass from pre to post, we could make a wider data set and calculate post - pre\n\nexscidata::dxadata |&gt;  \n  select(participant, time, include, starts_with(\"lean.\") & ends_with(\"_leg\")) |&gt; \n  pivot_longer(names_to = \"leg\", values_to = \"lean_mass\", cols = contains(\"lean.\")) |&gt;\n  mutate(leg = if_else(leg == \"lean.left_leg\", \"L\", \"R\")) |&gt; \n1  pivot_wider(names_from = time, values_from = lean_mass) |&gt;\n2  mutate(delta_lean_mass = post - pre) |&gt;\n  print()\n\n\n1\n\nPivot wider creates new columns based on names in time and values in lean_mass\n\n2\n\nThe new variables is calculated as the difference between pre and post-intervention values.\n\n\n\n\n# A tibble: 82 × 6\n   participant include leg     pre  post delta_lean_mass\n   &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;\n 1 FP28        incl    L      7059  7273             214\n 2 FP28        incl    R      7104  7227             123\n 3 FP40        incl    L      7190  7192               2\n 4 FP40        incl    R      7506  7437             -69\n 5 FP21        incl    L     10281 10470             189\n 6 FP21        incl    R     10200 10819             619\n 7 FP34        incl    L      6014  6326             312\n 8 FP34        incl    R      6009  6405             396\n 9 FP23        incl    L      8242  8687             445\n10 FP23        incl    R      8685  8480            -205\n# ℹ 72 more rows\n\n\n\n\n1.2.4 Joining data sets\nWe have constructed two smaller data sets, one indicating which leg performed low and moderate volume and one data set containing the lean mass values for each leg, pre- and post-intervention. Next step is to join the two.\ndplyr contains functions for joining data frames. There are, as illustrated in Figure 1.3 important differences between the functions where outer joins (left, right and full) keeps all observations in x, y and both x and y respectively. inner_join however, drops unmatched observations from both input data frames. Unlike the others, anti_join function removes observations in x that is present in y.\n\n\nCode producing the figure\nlibrary(ggVennDiagram) \nlibrary(ggplot2) \nlibrary(cowplot)\n\n# Joins can be illustrated with venn diagrams.\n# We do not need information about sets etc only \n# a way to fill three distinct areas. \n# The ggVennDiagram contains a function creating \n# shapes to be filled.\n\n\nlst &lt;- process_data(Venn(list(x = c(\"1\"), y = c(\"1\"))))\n\n# To avoid repeated code, create a function that plots\n# venn diagrams with options to indicate a title and \n# specify fill colors\njoin_illustration &lt;- function(lst, \n                              fills = c(\"steelblue\", \n                                        \"steelblue\", \n                                        \"white\"), \n                              title = \"left_join(x,y)\") {\n  \n  ggplot() + \n    \n  geom_sf(aes(fill = id), data = venn_region(lst), \n          color = \"black\") +\n  \n  theme_void() +\n  # Hard coded labels\n  geom_text(aes(x = c(300, 700), \n                y = c(500, 500), \n                label = c(\"x\", \"y\")), \n            size = 8, \n            color = \"gray20\") +\n  \n  \n  scale_fill_manual(values = fills) +\n  \n  labs(title = title) +\n  \n  theme(legend.position = \"none\")\n  \n  \n}\n\n\n# Each join gets its own fig. All figures are \n# ombined below with plot_grid from cowplot.\n\nleft &lt;- join_illustration(lst = lst, \n                  title = \"left_join(x,y)\", \n                  fills = c(\"steelblue\", \"steelblue\", \"white\"))\nright &lt;- join_illustration(lst = lst, \n                  title = \"right_join(x,y)\", \n                  fills = c(\"white\", \"steelblue\", \"steelblue\"))\ninner &lt;- join_illustration(lst = lst, \n                  title = \"inner_join(x,y)\", \n                  fills = c(\"white\", \"steelblue\", \"white\"))\nfull &lt;- join_illustration(lst = lst, \n                  title = \"full_join(x,y)\", \n                  fills = c(\"steelblue\", \"steelblue\", \"steelblue\"))\nanti &lt;- join_illustration(lst = lst, \n                  title = \"anti_join(x,y)\", \n                  fills = c(\"steelblue\", \"white\", \"white\"))\n\n\nplot_grid(left, right, inner, full, anti, ncol = 2)\n\n\n\n\n\nFigure 1.3: Functions for joining data sets.\n\n\n\n\nOur two data sets are pretty insensitive to dropped observations since the two data sets should be complete. We will use a left_join to put the data set together. This will match participant and leg because these two variables exists in both data sets. If we want to join by other variables we may specify such a variable. We’ll save the joined data set as leg_leanmass.\n\nleg_leanmass &lt;- leg_leanmass |&gt;\n  inner_join(participant_volume) |&gt;\n  print()\n\nJoining with `by = join_by(participant, leg)`\n\n\n# A tibble: 160 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP28        pre   incl    L          7059 multiple\n 2 FP28        pre   incl    R          7104 single  \n 3 FP40        pre   incl    L          7190 single  \n 4 FP40        pre   incl    R          7506 multiple\n 5 FP21        pre   incl    L         10281 single  \n 6 FP21        pre   incl    R         10200 multiple\n 7 FP34        pre   incl    L          6014 single  \n 8 FP34        pre   incl    R          6009 multiple\n 9 FP23        pre   incl    L          8242 single  \n10 FP23        pre   incl    R          8685 multiple\n# ℹ 150 more rows\n\n\n\n\n1.2.5 Filters and sorting rows\nWe included the variable include in our data set, this will make it possible to get rid of observations from participants that should be part of the final analysis. We can use filter to perform this operation.\n\nleg_leanmass |&gt;\n  filter(include == \"incl\") |&gt;\n  print()\n\n# A tibble: 136 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP28        pre   incl    L          7059 multiple\n 2 FP28        pre   incl    R          7104 single  \n 3 FP40        pre   incl    L          7190 single  \n 4 FP40        pre   incl    R          7506 multiple\n 5 FP21        pre   incl    L         10281 single  \n 6 FP21        pre   incl    R         10200 multiple\n 7 FP34        pre   incl    L          6014 single  \n 8 FP34        pre   incl    R          6009 multiple\n 9 FP23        pre   incl    L          8242 single  \n10 FP23        pre   incl    R          8685 multiple\n# ℹ 126 more rows\n\n\nThe double equal sign can be read as “equal to” in R, a common source of confusion is that the single equal sign (=) is used as a assignment operator.44 An assignment operator is used to assign data values to objects stored in the work space. The commonly used &lt;- is equivalent to =. Note however that -&gt; is different from =.\n\n\n\nThe filter function keeps rows of a data frame where a condition that we specify returns TRUE. To construct testable conditions that allows for results being either FALSE or TRUE we will use one, or a combination operators, such as\n\n\n\n==\n→ “equal to”\n\n\n!=\n→ “not equal to”\n\n\n&gt;\n→ “larger than”\n\n\n&lt;\n→ “smaller than”\n\n\n&gt;=, &lt;=\n→ “larger/smaller or equal to”\n\n\n!\n→ “NOT”\n\n\n&\n→ “AND”\n\n\n|\n→ “OR”\n\n\n\nThe above are all part of a collection of logical operators.5 We may demonstrate the mechanism by which filter operates by creating our own vector of TRUE/FALSE values. In the code chunk below a vector (INCLUDE) is created based on our include variable. A logical vector is created from the statement INCLUDE != \"excl\". We then use this vector in the filter statement.5 See here for a technical overview of logical operators.\n\n\n\n\nINCLUDE &lt;- leg_leanmass |&gt;\n  pull(include)\n\nINCLUDE &lt;- INCLUDE != \"excl\"\n\n\nINCLUDE\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[121]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[133]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[145]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[157] FALSE FALSE FALSE FALSE\n\nleg_leanmass |&gt;\n  filter(INCLUDE)\n\n# A tibble: 136 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP28        pre   incl    L          7059 multiple\n 2 FP28        pre   incl    R          7104 single  \n 3 FP40        pre   incl    L          7190 single  \n 4 FP40        pre   incl    R          7506 multiple\n 5 FP21        pre   incl    L         10281 single  \n 6 FP21        pre   incl    R         10200 multiple\n 7 FP34        pre   incl    L          6014 single  \n 8 FP34        pre   incl    R          6009 multiple\n 9 FP23        pre   incl    L          8242 single  \n10 FP23        pre   incl    R          8685 multiple\n# ℹ 126 more rows\n\n\nIn R, a vector of TRUE/FALSE (or in short form T/F) are is a special case which R will prohibit us from overwriting.\n\n1.2.5.1 Grouped filters\nUsing the dplyr syntax it is easy to e.g. filter or mutate based on a grouping of the data set. The function group_by creates a grouped data set. In the context of filtering in our data set we may want to filter out observations larger than the median from two time points.\n\nleg_leanmass |&gt;\n  group_by(time) |&gt;\n  filter(lean_mass &gt; median(lean_mass)) |&gt; \n  print()\n\n# A tibble: 80 × 6\n# Groups:   time [2]\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP21        pre   incl    L         10281 single  \n 2 FP21        pre   incl    R         10200 multiple\n 3 FP23        pre   incl    R          8685 multiple\n 4 FP38        pre   incl    L          8889 single  \n 5 FP38        pre   incl    R          8923 multiple\n 6 FP25        pre   incl    L          9664 single  \n 7 FP25        pre   incl    R          9198 multiple\n 8 FP19        pre   incl    L          9704 multiple\n 9 FP19        pre   incl    R          9806 single  \n10 FP13        pre   incl    L         10086 multiple\n# ℹ 70 more rows\n\n\nThe above operation removed exactly half of the observations, as expected since we wanted observations larger than the median from both time points. We may combine this statement with filtering away \"excl\" from the include variable.\n\nleg_leanmass |&gt;\n  group_by(time) |&gt;\n  filter(include != \"excl\", lean_mass &gt; median(lean_mass)) |&gt; \n  print()\n\n# A tibble: 68 × 6\n# Groups:   time [2]\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP21        pre   incl    L         10281 single  \n 2 FP21        pre   incl    R         10200 multiple\n 3 FP23        pre   incl    R          8685 multiple\n 4 FP38        pre   incl    L          8889 single  \n 5 FP38        pre   incl    R          8923 multiple\n 6 FP25        pre   incl    L          9664 single  \n 7 FP25        pre   incl    R          9198 multiple\n 8 FP19        pre   incl    L          9704 multiple\n 9 FP19        pre   incl    R          9806 single  \n10 FP13        pre   incl    L         10086 multiple\n# ℹ 58 more rows\n\n\nPutting two conditions in a filter call is like explicitly using & (AND) to combine statements. All conditions must evaluate to be TRUE for the row to be included in final output.\nAn alternative to grouping by the group_by function is to do a “per-operation grouping”6 using the .by argument. This does not leave a grouping in the data frame after filtering.6 See ?dplyr_by\n\nleg_leanmass |&gt;\n  filter(include != \"excl\", lean_mass &gt; median(lean_mass), .by = time) |&gt; \n  print()\n\n# A tibble: 68 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP21        pre   incl    L         10281 single  \n 2 FP21        pre   incl    R         10200 multiple\n 3 FP23        pre   incl    R          8685 multiple\n 4 FP38        pre   incl    L          8889 single  \n 5 FP38        pre   incl    R          8923 multiple\n 6 FP25        pre   incl    L          9664 single  \n 7 FP25        pre   incl    R          9198 multiple\n 8 FP19        pre   incl    L          9704 multiple\n 9 FP19        pre   incl    R          9806 single  \n10 FP13        pre   incl    L         10086 multiple\n# ℹ 58 more rows\n\n\n\n\n\n1.2.6 Summaries\nWe often want to reduce larger amount of data into some summaries, such as means, standard deviations, medians etc. These summaries may be calculated over any number of categorical variables representing e.g. groups of observations. Just like in the filtering statement above, we may work with a grouped data frame, or by using a per-operation grouping (.by).\nWe will calculate the median, first and third quartile, and minimum and maximum from each volume condition and time point. Below are both of the two alternatives of grouping used.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  group_by(time, volume) |&gt;\n  summarise(Min = min(lean_mass), \n            q25 = quantile(lean_mass, 0.25), \n            Median = median(lean_mass), \n            q75 = quantile(lean_mass, 0.75), \n            Max = max(lean_mass)) |&gt;\n  print()\n\n`summarise()` has grouped output by 'time'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 4 × 7\n# Groups:   time [2]\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 post  multiple  5343 7309.  8654. 10820. 13948\n2 post  single    5561 7201.  8772. 10453. 13526\n3 pre   multiple  5500 7010.  8590. 10104  13166\n4 pre   single    5289 7126.  8654  10125. 13166\n\nleanmass_sum &lt;- leg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  summarise(Min = min(lean_mass), \n            q25 = quantile(lean_mass, 0.25), \n            Median = median(lean_mass), \n            q75 = quantile(lean_mass, 0.75), \n            Max = max(lean_mass), \n            .by = c(time, volume)) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   multiple  5500 7010.  8590. 10104  13166\n2 pre   single    5289 7126.  8654  10125. 13166\n3 post  multiple  5343 7309.  8654. 10820. 13948\n4 post  single    5561 7201.  8772. 10453. 13526\n\n\nNotice how the data frames either have a persistent grouping, or no grouping depending on how we invoked grouping. Notice also that all values are nicely displayed, this is not always the case with summarise.\nConsider the following example\n\nvals &lt;- c(4.5, 6.7, 4.6, 5.1, NA)\n\nmean(vals)\n\n[1] NA\n\n\nThe mean of a vector of values containing a missing value returns NA. If we where to have missing values (NA) in our original data we would have recievied a NA in results. To drop an NA from such a summary we need to specify na.rm = TRUE as part of a summary function.\n\nvals &lt;- c(4.5, 6.7, 4.6, 5.1, NA)\n\nmean(vals, na.rm = TRUE)\n\n[1] 5.225\n\n\nR does not drop NA silently! This is a good thing as we want to get a notice when we are missing data. If we know we are missing data we need to explicitly type this in our calls. This “rule” is not always true as some functions silently drops NA, be aware!\n\n\n1.2.7 Arranging data frames\nAt last we might want to arrange a data frame for ease of use, or prior to making a table etc. Arranging does not change the data frame per se, only how it is displayed.\nWe’ll used our summarized data frame from above and sort based on the volume variable.\n\nleanmass_sum |&gt;\n  arrange(volume) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   multiple  5500 7010.  8590. 10104  13166\n2 post  multiple  5343 7309.  8654. 10820. 13948\n3 pre   single    5289 7126.  8654  10125. 13166\n4 post  single    5561 7201.  8772. 10453. 13526\n\n\nAny other column will also work for arranging\n\nleanmass_sum |&gt;\n  arrange(Median) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   multiple  5500 7010.  8590. 10104  13166\n2 post  multiple  5343 7309.  8654. 10820. 13948\n3 pre   single    5289 7126.  8654  10125. 13166\n4 post  single    5561 7201.  8772. 10453. 13526\n\n\nUsing a helper function (desc) reverses the sorting\n\nleanmass_sum |&gt;\n  arrange(desc(Median)) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 post  single    5561 7201.  8772. 10453. 13526\n2 pre   single    5289 7126.  8654  10125. 13166\n3 post  multiple  5343 7309.  8654. 10820. 13948\n4 pre   multiple  5500 7010.  8590. 10104  13166\n\n\nNotice that desc also works for character data\n\nleanmass_sum |&gt;\n  arrange(desc(volume)) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   single    5289 7126.  8654  10125. 13166\n2 post  single    5561 7201.  8772. 10453. 13526\n3 pre   multiple  5500 7010.  8590. 10104  13166\n4 post  multiple  5343 7309.  8654. 10820. 13948"
  },
  {
    "objectID": "data-viz.html#scientific-graphic-design",
    "href": "data-viz.html#scientific-graphic-design",
    "title": "1  Data visualization",
    "section": "1.4 Scientific graphic design",
    "text": "1.4 Scientific graphic design\nAn important rule of scientific graphics is, not to lie. Or as stated by Tufte (2001), “graphical excellence begins with telling the truth about the data”. Clear and honest representation of the data together with detailed labeling are key factors for avoiding lies (Tufte 2001).\nAnother key aspect in the construction of scientific graphs is to decide what to plot. Graphs are very good at showing differences, however, what differences should be show? In a two-group design (treatment vs. control) we should aim at showing the difference between groups, not the difference within groups (Ho et al. 2019). When data are grouped, or measurements repeated within experimental units (such as research participants), we should show aim at indicating this fact. When graphical summaries are shown, we should also aim at showing the underlying data(Tufte 2001).\n\n1.4.1 Revise and edit\nWhen trying to find a coherent guide for scientific graphics one quickly realize that guidelines are often in conflict with each other. We have to reach some pragmatic level of compromise in our work. How do we find this compromise? Tufte’s advice to constantly revise and edit is a good start (Tufte 2001). Like with writing we try to explain or show, but fail to do so. Multiple edits later our text is ready to communicate an idea to others, and we might have learned something too.\n\nTufte, Edward R. 2001. The Visual Display of Quantitative Information. 2. edition. Cheshire, Conn.: Graphics Press.\nIn practice a graph, or a collection of graphs are born from multiple revisions. Below we will revise our graph using a number of principles outlined by Tufte (Tufte 2001).\n\n1.4.1.1 Show the data\nOur original idea is shown below. We made a box-plot of raw lean mass values. A core shortcoming of this graph is that it hides uncertainty our sample size. We could add another layer on top of our bow-plots to show raw data. The geom geom_point is added with the additional arguments: shape = 21, position =position_jitterdodge(dodge.width = 0.75, jitter.width = 0.1). The change in shape creates the possibility to fill points. As we have specified fill in aesthetics each point will have a condition-wise fill.\n\n\nCode producing the figure\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  geom_point(shape = 21, position = position_jitterdodge(dodge.width = 0.75, \n                                                         jitter.width = 0.1))\n\n\n\n\n\nA boxplot with raw data plotted on top\n\n\n\n\nAre we showing the data now? Some aspects of the data are still lost. The fact that the experiment is a nested one is not obvious from this display. Could we connect related data points?\nIn the next graph we’ll try another alternative, using a line-graph we might be able to convey an aspect of the repeated measures design. We will also add a facet to show each volume condition.\n\n\nCode producing the figure\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume, group = participant)) + \n  \n  geom_line() +\n  geom_point(shape = 21) + \n  facet_grid(. ~ volume)\n\n\n\n\n\nA line graph grouping observations per participant and volume condition\n\n\n\n\nBut what is the real comparison here? Here we might actually display within-condition differences. The analog to statistical test might be that we show two within-condition t-tests and tell the reader that the effect in one group is greater than the other. This is not an honest test.\nTo revise further we might want to compare changes across conditions. We can do this and still highlight comparisons within participants since each participant performed both conditions. To accomplish this we need some data wrangling.\n\ndelta_lean &lt;- leg_leanmass |&gt;\n1  filter(include != \"excl\") |&gt;\n2  pivot_wider(names_from = time, values_from = lean_mass) |&gt;\n3  mutate(delta = post - pre) |&gt;\n  print()\n\n\n1\n\nUsing only included participants from our raw data set we first…\n\n2\n\ncreate a wide data set by time allowing for…\n\n3\n\na simple difference across time in each participant and condition.\n\n\n\n\n# A tibble: 68 × 7\n   participant include leg   volume     pre  post delta\n   &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 FP28        incl    L     multiple  7059  7273   214\n 2 FP28        incl    R     single    7104  7227   123\n 3 FP40        incl    L     single    7190  7192     2\n 4 FP40        incl    R     multiple  7506  7437   -69\n 5 FP21        incl    L     single   10281 10470   189\n 6 FP21        incl    R     multiple 10200 10819   619\n 7 FP34        incl    L     single    6014  6326   312\n 8 FP34        incl    R     multiple  6009  6405   396\n 9 FP23        incl    L     single    8242  8687   445\n10 FP23        incl    R     multiple  8685  8480  -205\n# ℹ 58 more rows\n\n\nWe have saved the data set in a new object called delta_lean we will use this for plotting.\n\n\nCode producing the figure\ndelta_lean |&gt;\n  ggplot(aes(volume, delta, fill = volume, group = participant)) + \n  geom_line() + \n  geom_point(shape = 21)\n\n\n\n\n\nA line graph grouped by participant comparing conditions\n\n\n\n\nIt could be argued that the order of the factor variable volume is not accurately representing the data. Multiple is larger than single and the graph might be more accurate in this respect if we change this variable. I will do it as a pre-plotting operation. We may then also change the labels.\n\n\nCode producing the figure\ndelta_lean |&gt;\n  \n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  \n  ggplot(aes(volume, delta, \n             fill = volume, \n             group = participant)) + \n  geom_line() + \n  geom_point(shape = 21) \n\n\n\n\n\nA line graph grouped by participant comparing conditions\n\n\n\n\n\n\n1.4.1.2 Maximize the data-ink ratio\nA guiding principle in Tufte’ guideline is to remove non-data ink. We should aim to maximize the amount of ink used to display the data. Non-data ink can be removed by manipulating theme components. A great start might be to use a built in theme, theme_minimal.\n\n\nCode producing the figure\ndelta_lean |&gt;\n  \n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  \n  ggplot(aes(volume, delta, \n             fill = volume, \n             group = participant)) + \n  geom_line() + \n  geom_point(shape = 21) +\n  \n  theme_minimal()\n\n\n\n\n\nA line graph grouped by participant comparing conditions, reducing non-data ink with theme_minimal.\n\n\n\n\nThe legend is redundant, it can be removed since this information is already present in the x axis. The x-axis title is redundant as the information is duplicated in the labels. Some grid lines can be removed without loss of information, maybe even all of them. Let’s add a line manually to show the 0 change. We can access these options using the theme function and elements manipulated therein. Placing the theme after theme_minimal in our call makes sure that we don’t bring back elements from the pre-built theme. Let’s also add a more descriptive label on the y-axis.\n\n\nCode producing the figure\ndelta_lean |&gt;\n  \n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  \n  ggplot(aes(volume, delta, \n             fill = volume, \n             group = participant)) + \n  \n  geom_hline(yintercept = 0, color = \"gray90\") +\n  \n  geom_line() + \n  geom_point(shape = 21) +\n  \n  labs(y = \"Change in lean mass from pre- to post-intervention (g)\") +\n  \n  theme_minimal() + \n  \n  theme(legend.position = \"none\", \n        axis.title.x = element_blank(), \n        panel.grid.major.x = element_blank(), \n        panel.grid.minor.y = element_blank(), \n        panel.grid.major.y = element_blank())\n\n\n\n\n\nA line graph grouped by participant comparing conditions, reducing non-data ink with theme_minimal.\n\n\n\n\n\n\n1.4.1.3 Erase redundant data ink\nWe have used points to represent the start and end of each line. This might be a case of redundant data ink.\n\n\nCode producing the figure\ndelta_lean |&gt;\n  \n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  \n  ggplot(aes(volume, delta, \n             fill = volume, \n             group = participant)) + \n  \n  geom_hline(yintercept = 0, color = \"gray90\") +\n  \n  geom_line() + \n\n  \n  labs(y = \"Change in lean mass from pre- to post-intervention (g)\") +\n  \n  theme_minimal() + \n  \n  theme(legend.position = \"none\", \n        axis.title.x = element_blank(), \n        panel.grid.major.x = element_blank(), \n        panel.grid.minor.y = element_blank(), \n        panel.grid.major.y = element_blank())\n\n\n\n\n\nA line graph grouped by participant comparing conditions, reducing non-data ink with theme_minimal and removing redundant data ink by removing points.\n\n\n\n\nTo make the graph even more light weight we could consider making lines a bit transparent. Using alpha = 0.5 we can add transparency to lines.\n\n\nCode producing the figure\ndelta_lean |&gt;\n  \n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  \n  ggplot(aes(volume, delta, \n             fill = volume, \n             group = participant)) + \n  \n  geom_hline(yintercept = 0, color = \"gray90\") +\n  \n  geom_line(alpha = 0.5) + \n\n  \n  labs(y = \"Change in lean mass from pre- to post-intervention (g)\") +\n  \n  theme_minimal() + \n  \n  theme(legend.position = \"none\", \n        axis.title.x = element_blank(), \n        panel.grid.major.x = element_blank(), \n        panel.grid.minor.y = element_blank(), \n        panel.grid.major.y = element_blank())\n\n\n\n\n\nA line graph grouped by participant comparing conditions, reducing non-data ink with theme_minimal and removing redundant data ink by removing points and adding transparency.\n\n\n\n\n\n\n1.4.1.4 Making comparisons\nWe now have a graph that represents the data, could we aid interpreting the figure? Perhaps we could add some information showing average changes per condition? Below we will construct a data frame of averages for each condition and add it to the figure.\n\n\nCode producing the figure\ndescriptives &lt;- delta_lean |&gt;\n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  summarise(.by = volume, \n            m = mean(delta))\n\n\ndelta_lean |&gt;\n  \n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  \n  ggplot(aes(volume, delta, \n             fill = volume, \n             group = participant)) + \n  \n  geom_hline(yintercept = 0, color = \"gray90\") +\n  \n  \n1  geom_point(data = filter(descriptives, volume== \"Low-volume\"),\n                           aes(volume, m, group = NULL, fill = NULL), \n                           position = position_nudge(x = -0.1)) +\n  \n2    geom_point(data = filter(descriptives, volume== \"Moderate-volume\"),\n                           aes(volume, m, group = NULL, fill = NULL), \n                           position = position_nudge(x = 0.1)) +\n  \n  \n  \n  geom_line(alpha = 0.5) + \n\n  \n  labs(y = \"Change in lean mass from pre- to post-intervention (g)\") +\n  \n  theme_minimal() + \n  \n  theme(legend.position = \"none\", \n        axis.title.x = element_blank(), \n        panel.grid.major.x = element_blank(), \n        panel.grid.minor.y = element_blank(), \n        panel.grid.major.y = element_blank())\n\n\n\n1\n\nTwo point layers are added to make it easy to plot points besides lines. Notice that the x-axis factor must be correctly formatted\n\n2\n\nThe other point layer, here position_nudge is positive.\n\n\n\n\n\n\n\nA line graph grouped by participant comparing conditions, reducing non-data ink with theme_minimal and removing redundant data ink by removing points and adding transparency. Adding group averages with geom_point.\n\n\n\n\nAgain, we might not be giving the reader of the graph the full story. Recently a new type of graph has been suggested to aid interpretation of two-group comparisons. In addition to means we could add the estimate of the difference between groups. These plots are called estimation plots (Ho et al. 2019). In our previous work we used different variations of ANCOVA models to adjust for baseline values (Hammarström et al. 2020) while modelling the change score. Let’s start by fitting the model. Since the design is a bit tricky we need to let the model know that observations are grouped by participant. We can use the same delta_lean data set to fit the model.\n\nHo, Joses, Tayfun Tumkaya, Sameer Aryal, Hyungwon Choi, and Adam Claridge-Chang. 2019. “Moving Beyond P Values: Data Analysis with Estimation Graphics.” Nature Methods 16 (7): 565–66. https://doi.org/10.1038/s41592-019-0470-3.\n\nHammarström, Daniel, Sjur Øfsteng, Lise Koll, Marita Hanestadhaugen, Ivana Hollan, William Apró, Jon Elling Whist, Eva Blomstrand, Bent R. Rønnestad, and Stian Ellefsen. 2020. “Benefits of higher resistance-training volume are related to ribosome biogenesis.” The Journal of physiology 598 (3): 543–65. https://doi.org/10.1113/JP278455.\n\nlibrary(lme4)\n\nmod &lt;- lmer(delta ~ scale(pre) + volume + (1|participant), \n            data = delta_lean)\n\n1mod_results &lt;- data.frame(cbind(coef(summary(mod)), confint(mod)[3:5, ]))\n\n\n1\n\nThe output from the model is saved in a new object, including confidence intervals for each coefficient.\n\n\n\n\nOur model gives us one coefficient of interest, volumesingle. This is the difference between multiple and single sets change in lean mass. This coefficient has an accompanying confidence interval that can be used for inference. Let’s add the difference between groups as an additional point to the plot together with a confidence interval and a second scale.\n\n\nCode producing the figure\ndescriptives &lt;- delta_lean |&gt;\n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  summarise(.by = volume, \n            m = mean(delta))\n\n\n\n1\nzero &lt;- descriptives |&gt;\n  filter(volume == \"Low-volume\") |&gt;\n  pull(m)\n\n2\nest &lt;- zero + (- mod_results[3,1])\nciu &lt;- - mod_results[3,4] + zero\ncil &lt;- - mod_results[3,5] + zero\n\n\n\ndelta_lean |&gt;\n  \n  mutate(volume = factor(volume, levels = c(\"single\", \"multiple\"), \n                         labels = c(\"Low-volume\", \"Moderate-volume\"))) |&gt;\n  \n  ggplot(aes(volume, delta, \n   \n             group = participant)) + \n  \n    \n  geom_point(data = filter(descriptives, volume== \"Low-volume\"),\n                           aes(volume, m, group = NULL, fill = NULL), \n                           position = position_nudge(x = -0.1)) +\n  \n3\n  geom_segment(y = zero, yend = zero, x = 0.95, xend = 2.2, color = \"gray50\", \n               lty = 1) +\n4\n    geom_errorbar(aes(y = est, ymin = cil, \n                ymax = ciu, x = 2.1), \n                width = 0, color = \"gray50\") +\n  \n  \n  geom_point(data = filter(descriptives, volume== \"Moderate-volume\"),\n                           aes(volume, m, group = NULL, fill = NULL), \n                           position = position_nudge(x = 0.1), \n             shape = 24, \n             size = 2, \n             fill = \"gray60\") +\n\n\n\n  geom_line(alpha = 0.5) + \n \n  labs(y = \"Change in lean mass from pre- to post-intervention (g)\") +\n  \n  theme_minimal() + \n  \n  theme(legend.position = \"none\", \n        axis.title.x = element_blank(), \n        panel.grid.major.x = element_blank(), \n        panel.grid.minor.y = element_blank(), \n        panel.grid.major.y = element_blank())\n\n\n\n1\n\nA “zero line” is created from the descriptive data in the low-volume group\n\n2\n\nThe confidence interval is “corrected” to the observed data as the model CI only shows the differences between groups. Notice that estimates are reversed in the model.\n\n3\n\nA segment is added to represent the “zero line”, the mean in low-volume.\n\n4\n\nAn errorbar is used around the descriptive data for the moderate volume group.\n\n\n\n\n\n\n\nA line graph grouped by participant comparing conditions, reducing non-data ink with theme_minimal and removing redundant data ink by removing points and adding transparency. Adding group averages with geom_point.\n\n\n\n\nThe resulting graph shows the change from pre- to post-intervention in each condition per participant by lines. The average at the reference category represents a baseline to which the moderate volume condition is compared. Inference can be made from a 95% confidence interval around the moderate-volume condition."
  },
  {
    "objectID": "version-control.html#introduction-to-git-and-github",
    "href": "version-control.html#introduction-to-git-and-github",
    "title": "2  Version control and collaborative scientific coding",
    "section": "2.1 Introduction to git and GitHub",
    "text": "2.1 Introduction to git and GitHub\nGit is a version control system that you install on your local machine. It helps you create a record of changes that you make to files in a specific repository where git is initialized. The git software stores earlier versions of your repository content in a hidden directory called .git.\nGit works great for working with plain text files, such as .txt, .md, .qmd, .csv. With such files git can provide you with an overview of changes or diffs that has occurred between two versions of the file. Other file types such as .docx or .xlsx are also tracked by git but changes are not human readable in the git system.\nGit can be set up to communicate with an online repository. There are several alternatives for online hosting of version controlled repositories but GitHub seems to be a popular alternative in the (data) science community. GitHub offers online hosting and tools for collaboration.\nTo enable version control and collaboration you must therefore have git installed and an active GitHub account.\n\n2.1.1 Accounts and git-to-GitHub integration\nGit can be installed from https://git-scm.com. Git requires no additional account information or software. To allow for RStudio to act as a git client, you need to tell RStudio where your installation of git is located. This is done under Tools &gt; Global options &gt; Git/SVN.\nYour local version history maintained by git can be controlled from your terminal window. However, to connect to the online services of github you will need to set git up with your github account.\nGithub has recently made changes to its authentication protocol, and seems to be in the process of making additional changes. GitHub CLI provides a command line interface to GitHub that makes it easy to authenticate. Install GitHub CLI here and run gh auth login in your terminal to set things up.\n\n\n2.1.2 Local git edits\nAs already mentioned, git stores a record of changes to files in a given repository. A repository is a directory in which you have initialized git. We can do this in any directory using the command line by typing\ngit init\nin our terminal. If you initialize a git (version control) project using RStudio it will run this command for you. You may check that you have initialized the version control system by typing\ngit status\nYou make decisions on what files to add to your version history and when to do so. A file, let us say file-a.txt is added to the staging area with the command\ngit add file-a.txt\nThe staging area is where files are kept until you commit a snapshot of them into the version history. We could also stage all files that have changes made to them by typing\ngit add -A\nThe next step is to commit changes. A commit is a snapshot of the repository or files at a given moment. We perform a commit when after staging files type\ngit commit -m \"my commit message\"\nThe -m \"my commit message\" adds a commit short commit message to the commit. This should be a description of the changes made to the repository. A longer commit message can be added by only initializing a commit using git commit. This command will bring up a dialog in your terminal making it possible to write a short message in the first line. After leaving one blank line a longer commit message can be added.\nWhen a file has been commited to the version history it is marked as unmodified until you make changes to the file. Modified files can again be staged (e.g. git add &lt;file&gt;) and commited.\nFiles that were are tracked by mistake can be un-tracked without being removed using\ngit rm --cached &lt;file&gt;\nThis leaves the file in your local folder but removes it from the repository. Using git rm &lt;file&gt; removes the file from disc.\nA local git “edit cycle” is shown in Figure 2.1.\n\n\nCode\nlibrary(ggplot2); library(ggtext)\n\nggplot(data.frame(x = c(0,1), y = c(0,1)), aes(x, y)) + \n  \n  scale_y_continuous(limits = c(0.3, 1)) +\n  \n  # Workspace\n  geom_rect(aes(xmin = 0.01, \n            xmax = 0.6, \n            ymin = 0.35, \n            ymax = 1), \n            fill = \"steelblue\", \n            alpha = 0.2) +\n  \n  geom_rect(aes(xmin = 0.02, \n            xmax = 0.3, \n            ymin = 0.35, \n            ymax = 0.92), \n            fill = \"steelblue\", \n            alpha = 0.2) +\n  \n  geom_rect(aes(xmin = 0.31, \n            xmax = 0.58, \n            ymin = 0.35, \n            ymax = 0.92), \n            fill = \"steelblue\", \n            alpha = 0.2) +\n \n    annotate(\"richtext\", \n           x = c(0.02, 0.32),  \n           hjust = 0,\n           y = 0.89, \n           label = c(\"*Untracked*\", \"*Tracked*\"),\n           fill = NA, label.color = NA) + \n   \n  \n  annotate(\"richtext\", \n           x = 0.02, \n           y = 0.97, \n           label = \"**Workspace**\",\n           hjust = 0,\n           size = 8, \n           fill = NA, label.color = NA, # remove background and outline\n          label.padding = grid::unit(rep(0, 4), \"pt\")) + # remove padding) +\n  \n  # Stage area\n  geom_rect(aes(xmin = 0.61, \n            xmax = 1, \n            ymin = 0.35, \n            ymax = 1), \n            fill = \"purple\", \n            alpha = 0.2) +\n  \n\n  \n    annotate(\"richtext\", \n           x = 0.62, \n           y = 0.97, \n           label = \"**Staging area**\",\n           hjust = 0,\n           size = 8, \n           fill = NA, label.color = NA, # remove background and outline\n          label.padding = grid::unit(rep(0, 4), \"pt\")) + # remove padding) +\n  \n  \n  \n  ## Labels and arrows\n  \n    \n  annotate(\"segment\", y = c(0.85, 0.85), \n                   yend = c(0.85, 0.82),  \n                   x = c(0.1, 0.9), \n                   xend = c(0.9, 0.9), \n                   arrow = arrow(length = unit(c(0, 2.5), \"mm\"), type = \"closed\")) +\n  \n  \n    \n  geom_label(aes(x = 0.62, y = 0.85 , label = \"&lt;file&gt;\"), \n             hjust = 0) +\n  \n  \n  geom_label(aes(x = 0.02, y = 0.85 , label = \"Add file `git add &lt;file&gt;`\"), \n             hjust = 0) +\n  \n  \n   annotate(\"segment\", \n            y = c(0.8,0.75), \n            yend = c(0.75, 0.75), \n            x = c(0.9,0.9), \n            xend = c(0.9, 0.48), \n            arrow = arrow(length = unit(c(0, 2.5), \"mm\"), type = \"closed\")) +\n  \n\n  \n       annotate(\"segment\", \n            y = c(0.75, 0.7), \n            yend = c(0.7, 0.7), \n            x = c(0.35, 0.35), \n            xend = c(0.35, 0.4), \n            arrow = arrow(length = unit(c(0, 2.5), \"mm\"), type = \"closed\")) +\n  \n  \n  \n  geom_label(aes(x = 0.65, y = 0.8 , label = \"Commit file `git commit -m 'msg'`\"), \n             hjust = 0) +\n  \n\n    geom_label(aes(x = 0.31, y = 0.75 , label = \"Edit unmodified     \"), \n             hjust = 0) +\n  \n\n  \n  \n     annotate(\"segment\", \n            y = c(0.7, 0.7), \n            yend = c(0.7, 0.67), \n            x = c(0.5, 0.9), \n            xend = c(0.9, 0.9), \n            arrow = arrow(length = unit(c(0, 2.5), \"mm\"), type = \"closed\")) +\n  \n  \n      geom_label(aes(x = 0.8, y = 0.7 , label = \"&lt;file&gt;\"), \n             hjust = 0) +\n\n  \n  \n  \n      geom_label(aes(x = 0.40, y = 0.7 , label = \"Stage modified `git add &lt;file&gt;`\"), \n             hjust = 0) +\n  \n  \n\n  \n      annotate(\"segment\", \n            y = c(0.65,0.65), \n            yend = c(0.65, 0.62), \n            x = c(0.8, 0.35), \n            xend = c(0.35, 0.35), \n            arrow = arrow(length = unit(c(0, 2.5), \"mm\"), type = \"closed\")) +\n  \n    geom_label(aes(x = 0.65, y = 0.65 , label = \"Commit file `git commit -m 'msg'`\"), \n             hjust = 0) +\n  \n  \n\n  \n  ## Possible routs from unmodified\n  \n  ## Modify and commit \n  ## Remove (untrack)\n         annotate(\"segment\", \n            y = c(0.6, 0.6), \n            yend = c(0.6, 0.54), \n            x = c(0.4, 0.4), \n            xend = c(0.70, 0.4),\n            lty = 2,\n            arrow = arrow(length = unit(c(2.5, 2.5), \"mm\"), type = \"closed\")) +\n  ## File in staging area\n         geom_label(aes(x = 0.75, y = 0.6 , label = \"&lt;file&gt;\"), \n             hjust = 0.5) +\n  \n  \n  \n  ## Untrack file\n       annotate(\"segment\", \n            y = c(0.5), \n            yend = c(0.5), \n            x = c(0.4), \n            xend = c(0.1), \n            lty = 2,\n            arrow = arrow(length = unit(c(2.5), \"mm\"), type = \"closed\")) +\n  \n      geom_label(aes(x = 0.31, y = 0.60 , label = \"Unmodified    \"), \n             hjust = 0) +\n  \n\n\n\n  \n    ## Remove file (delete)\n       annotate(\"segment\", \n            y = c(0.5), \n            yend = c(0.33), \n            x = c(0.4), \n            xend = c(0.4), \n            lty = 2,\n            arrow = arrow(length = unit(c(2.5), \"mm\"), type = \"closed\")) +\n    \n      annotate(\"label\", \n             x = 0.31, y = 0.5 , \n             label = \"Untrack file\\n`git rm --cached &lt;file&gt;`\",\n\n             hjust = 0) +\n  \n  ## File in trash\n        geom_label(aes(x = 0.4, y = 0.30 , label = \"&lt;file&gt;\"), \n             hjust = 0.5) +\n  \n  \n  ## File untracked\n     geom_label(aes(x = 0.06, y = 0.5 , label = \"&lt;file&gt;\"), \n             hjust = 0.5) +\n  \n  \n    geom_label(aes(x = 0.31, y = 0.40 , label = \"Delete file from disc\\n`git rm &lt;file&gt;`\", \n             hjust = 0)) +\n  \n  \n  \n  theme_void()\n\n\n\n\n\nFigure 2.1: A cycle of local git edits. A files is added to the staging area by git add &lt;file&gt; and comitted to the local repository by git commit. The file is edited and is marked as modified after which it is staged (git add &lt;file&gt;). Again, staged modifications are commited and the file is once again marked as unmodified until edited. Files may be untracked from the repository or deleted from disc using git rm with or without the --cached option.\n\n\n\n\n\n\n2.1.3 Local and online git usage\nYour local git folder can be hocked up to a online repository. The online repository, or remote, is the repository in which you collaborate with others. The online repository can be set up as a starting point for your project or created from the command line in an already initialized git repository using GitHub CLI.\n\n2.1.3.1 Starting with GitHub\nAfter logging on to GitHub, select New, or go to github.com/new. This will bring you to a schema that will create your repository. You need to give it a name, describe it, decide if you want to initialize with a readme file (you want to do that) and choose a license. Once all this is done you will be able to copy the HTTPS address that you find under Code in your repository in GitHub. The HTTPS address is then entered in the New Project Dialog in RStudio after selecting Version Control under the different project types.\nYou have now initialized a remote repository and then cloned it to your computer as a local copy. You may now make changes to the project and add/commit these to you local version history.\n\n\n2.1.3.2 Starting with a RStudio project\nWhen starting up a new RStudio project without version control you have the opportunity to initialize git in the dialog box. If you decide not to do this, the next step should be to write git init in your terminal to initialize in your current project folder.\nWe can now create a remote repository using GitHub CLI with the command gh repo create. If this command is used without any subcommand you will be guided through the process on the command line. If you have your project running and wants to use it to create a repository on GitHub you should select “Push an existing local directory to GitHub”. You will be asked:\n\nThe path to your local repository (defaults to ., the current directory)\nThe name of the repository (defaults to your local folder name)\nIf the repository should be private or public.\nA description of the repository (A short description of what the repository do/contain)\nIf a remote should be added (Yes)\nWhat the remote should be called (Default to origin)\n\nIf successful, you will get a message telling you that the remote has been added. Your GitHub profile will now have a repository acting as the remote for your local repository.\n\n\n2.1.3.3 Local to remote workflows\nThe online remote repository may have several purposes in the context of writing a scientific paper. It will act as the repository that you and any collaborators work together on. It can be used for showcasing code and computations and thereby supporting your paper. It can also act as a backup and reference for yourself.\nThe basic workflow (Figure 2.2) for updating and downloading from the remote repository can include git push to push all local commits to the remote. This will update the remote with any changes you have committed to the version history. When the remote has been changed you will be able to download these in two ways. git pull downloads all changes and directly overwrite your local files, updating them to their latest versions. This also include removal of files and addition of new files. If you want to have more control you can git fetch changes which updates the local repository, but not your working directory. Using git merge you can merge downloaded versions with your working directory. git fetch and git merge can be a way to continue working on files but updating your repository with the latest changes.\n\n\nCode\nggplot(data.frame(x = c(0,1), y = c(0,1)), aes(x, y)) + \n  \n  scale_y_continuous(limits = c(0.3, 1)) +\n  \n  # Local working directory / Repository\n  geom_rect(aes(xmin = 0.01, \n            xmax = 0.6, \n            ymin = 0.35, \n            ymax = 1), \n            fill = \"steelblue\", \n            alpha = 0.2) +\n  \n    geom_rect(aes(xmin = 0.02, \n            xmax = 0.3, \n            ymin = 0.35, \n            ymax = 0.92), \n            fill = \"steelblue\", \n            alpha = 0.2) +\n   \n  geom_rect(aes(xmin = 0.31, \n            xmax = 0.58, \n            ymin = 0.35, \n            ymax = 0.92), \n            fill = \"steelblue\", \n            alpha = 0.2) +\n  \n  # Remote repository\n  geom_rect(aes(xmin = 0.7, \n            xmax = 0.95, \n            ymin = 0.35, \n            ymax = 1), \n            fill = \"steelblue\", \n            alpha = 0.2) +\n \n \n    annotate(\"richtext\", \n           x = c(0.02, 0.32),  \n           hjust = 0,\n           y = 0.89, \n           label = c(\"*Working directory*\", \"*Local repository*\"),\n           fill = NA, label.color = NA) + \n   \n  \n  annotate(\"richtext\", \n           x = c(0.02, 0.7), \n           y = c(0.97, 0.97), \n           label = c(\"**Workspace**\",\"**Remote**\"),\n           hjust = 0,\n           size = 8, \n           fill = NA, label.color = NA) + # remove padding) \n\n  \n      # Git add, commit\n  # git push\n  # git pull\n  # git fetch / merge\n       annotate(\"segment\", \n            y = c(0.8, 0.7, 0.6, 0.5, 0.5), \n            yend = c(0.8, 0.7, 0.6, 0.5, 0.5), \n            x = c(0.1, 0.4, 0.8, 0.8, 0.4), \n            xend = c(0.5, 0.8, 0.12, 0.5, 0.12), \n            arrow = arrow(length = unit(c(2.5), \"mm\"), type = \"closed\")) +\n    \n      annotate(\"label\", \n             x = c(0.1, 0.4, 0.8, 0.8, 0.35), \n             y = c(0.8 ,0.7, 0.6, 0.5, 0.5), \n             label = c(\"git add &lt;file&gt;\\n git commit -m 'msg'\",\n                       \"git push\", \n                       \"git pull\", \n                       \"git fetch\", \n                       \"git merge\"),\n\n             hjust = 0) +\n  \n  theme_void()\n\n\n\n\n\nFigure 2.2: Local git commits can be pushed to a remote repository, this updates the remote with your local changes. If changes are made to the remote these can be pulled to the local reposotory and working directory. Git pull overwrites your local files in the working directory at the same time as updating the local version history. Git fetch downloads changes to your local repository without merging files. Git merge attempts to merge files in the working directory with the most recent changes from the remote repository.\n\n\n\n\n\n\n\n2.1.4 Branches and pull requests\nSometimes changes to a repository can be expected to get big. Multiple files needs updating affecting multiple aspects of the repository. Instead of doing these as incremental steps in the main repository we could create a new branch. A branch starts at a specific state of the repository and adds new history without affecting the main branch. When changes have been made to the branch they can be incorporated into the main branch using merge or as a pull request.\n\n\n2.1.5 Forks and pull requests\nForks are copies of an online repository from one user to another user where the receiving user gets the privileges to make changes in the repository.\n\n\n2.1.6 Issues\nIssues are an feature of GitHub which allows for creating notes on potential improvements, bugs etc. They can be accessed and edited using GitHub CLI using gh issue or in the GitHub web interface.\n\n\n2.1.7 GitHub pages\nGitHub pages is a service that allow for web hosting from your github repository."
  },
  {
    "objectID": "version-control.html#a-workflow-for-a-scientific-paper",
    "href": "version-control.html#a-workflow-for-a-scientific-paper",
    "title": "2  Version control and collaborative scientific coding",
    "section": "2.2 A workflow for a scientific paper",
    "text": "2.2 A workflow for a scientific paper\nA scientific paper (or a thesis) is reproducible if the data, code and documentation is available.\n\n2.2.1 The repository\nOrganizing the repository is important for collaboration and communication\n\n2.2.1.1 README\n\n\n2.2.1.2 Folder structure\n\n2.2.1.2.1 data\n\n\n\n2.2.1.3 R\n\n\n2.2.1.4 derived-data\n\n\n2.2.1.5 figures\n\n\n2.2.1.6 docs\n\n\n2.2.1.7 resources\n\n\n\n2.2.2 Structuring code in different scripts"
  },
  {
    "objectID": "writing-packages.html#increased-reproducibility",
    "href": "writing-packages.html#increased-reproducibility",
    "title": "3  R packages for data management and sharing",
    "section": "3.1 Increased reproducibility",
    "text": "3.1 Increased reproducibility\nA basic principle in reproducible research is that the data and code used to generate results should be made available. Ideally, each component of a reproducible report (paper, thesis or similar) should be documented and organized to allow for independent execution of code that supports conclusions (Peng 2011). Publishers and journals have started to highlight reproducible scientific work, sometimes under the term open research1. Similarly, funding agencies are also taking steps to support or even demand open research practices, including reproducible research. Even though principles are well described and researchers have many incentives to publish reproducible open research, the fail to do so. Reproducible research is still not common practice. There are several reasons why this is the case, reasons such as lack of skills and knowledge on how to do it, insecurity or embarrassment in sharing behind-the-scenes work or fear of inappropriate use (Gomes et al. 2022).1 Wiley marks publications with “open research badges” to indicate shared data, pre-registration and open material. The journal Biostatistics was an early adopter of marking papers with code, data and reproducible marks (Peng 2011).\nPeng, R. D. 2011. “Reproducible Research in Computational Science.” Science 334 (6060): 1226–27. https://doi.org/10.1126/science.1213847.\n\nGomes, Dylan G. E., Patrice Pottier, Robert Crystal-Ornelas, Emma J. Hudgins, Vivienne Foroughirad, Luna L. Sánchez-Reyes, Rachel Turba, et al. 2022. “Why Don’t We Share Data and Code? Perceived Barriers and Benefits to Public Archiving Practices.” Proceedings of the Royal Society B: Biological Sciences 289 (1987): 20221113. https://doi.org/10.1098/rspb.2022.1113.\n\n\n\n\nSharing code and data in efficient way may be difficult if you do not rely on software and workflows designed for this purpose."
  },
  {
    "objectID": "writing-packages.html#r-package-basics",
    "href": "writing-packages.html#r-package-basics",
    "title": "3  R packages for data management and sharing",
    "section": "3.1 R package basics",
    "text": "3.1 R package basics\nAn R package is a structured\n\n3.1.1 Incorporating data into R packages\n\n\n3.1.2 Documenting data"
  },
  {
    "objectID": "writing-packages.html#sharing-packages",
    "href": "writing-packages.html#sharing-packages",
    "title": "3  R packages for data management and sharing",
    "section": "3.2 Sharing packages",
    "text": "3.2 Sharing packages"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Gelman, Andrew, Cristian Pasarica, and Rahul Dodhia. 2002. “Let’s\nPractice What We Preach.” The American Statistician 56\n(2): 121–30. https://doi.org/10.1198/000313002317572790.\n\n\nHammarström, Daniel, Sjur Øfsteng, Lise Koll, Marita Hanestadhaugen,\nIvana Hollan, William Apró, Jon Elling Whist, Eva Blomstrand, Bent R.\nRønnestad, and Stian Ellefsen. 2020. “Benefits of higher\nresistance-training volume are related to ribosome biogenesis.”\nThe Journal of physiology 598 (3): 543–65. https://doi.org/10.1113/JP278455.\n\n\nTufte, Edward R. 2001. The Visual Display of Quantitative\nInformation. 2. edition. Cheshire, Conn.: Graphics Press.\n\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.”\nJournal of Computational and Graphical Statistics 19 (1): 3–28.\nhttps://doi.org/10.1198/jcgs.2009.07098.\n\n\n———. 2014. “Tidy Data.” Journal of Statistical\nSoftware; Vol 1, Issue 10 (2014), September. https://www.jstatsoft.org/v059/i10\nhttp://dx.doi.org/10.18637/jss.v059.i10.\n\n\n———. 2016. Ggplot2 : Elegant Graphics for Data Analysis. 2nd\ned. Use r! Cham: Springer International Publishing : Imprint: Springer.\nhttps://doi.org/10.1007/978-3-319-24277-4.\n\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of\nGraphics. 2nd ed. Statistics and Computing. New York: Springer."
  },
  {
    "objectID": "data-viz.html#ggplot-examples",
    "href": "data-viz.html#ggplot-examples",
    "title": "1  Data visualization",
    "section": "1.3 ggplot examples",
    "text": "1.3 ggplot examples\nAs hinted above, ggplot2 presents us with almost endless opportunities for graphical representations of our data. We will use the data we have wrangled above to better understand the ggplot2 syntax.\nIn our summary of the lean mass data we have calculated a number of summary statistics that can be used to create a type of range-quartile-median plot not unlike the plots suggested by Tukey7. We will use time as a categorical variable on the x-axis and our summary statistics displayed on the y-axis.7 Tukey (1977) is considered to be creator of the box-plot. However, Spear may have suggested a predecessor to the box-plot in Charting statistics (Spear 1952).\nTukey, John Wilder. 1977. Exploratory Data Analysis. Addison-Wesley Series in Behavioral Science. Reading, Mass: Addison-Wesley Pub. Co.\n\nSpear, M. E. 1952. Charting Statistics. McGraw-Hill. https://books.google.no/books?id=1vBOAAAAMAAJ.\n\n\nggplot(data = leanmass_sum, aes(time, Median))\n\n\n\n\nWe have specified a data set, and variables for the x and y axis. This specification gives us an empty coordinate system. We need to add geometric objects to represent the data mapped to x and y coordinates. Let’s start simple\n\nggplot(data = leanmass_sum, aes(time, Median)) +\n    geom_point()\n\n\n\n\nThe points now represents our median values per time point. There are a number of geometric objects, or geoms in ggplot2. You are also able to extend ggplot2 by creating your own geoms, this has been done in many packages to make a specific geometric available. In ggplot2 there are about 50 geoms available and in addition, a number of statistical transformations8.8 See https://ggplot2.tidyverse.org/reference/ for a complete inventory.\n\n\n\nIn our plot in the making, instead of points we may add rectangular shapes with a bit of reorganization of the data.\n\nleanmass_sum |&gt;\n  mutate(Time = if_else(time == \"pre\", 1, 2)) |&gt;\n  ggplot( aes(Time, Median, fill = volume)) +\n    \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = Median, \n                  ymax = q75), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) + \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = q25, \n                  ymax = Median), \n            color = \"black\", \n            position = position_dodge(width = 0.4))\n\n\n\n\nWe have hacked our way to a plot showing the median as a line inside a box covering the interquartile range. Let’s add bars representing the minimum and maximum values. Note that we are using layers and we want our range bars to not over plot the boxes. We must therefore add them prior to the boxes. We will also scale the x-axis and add labels.\n\nleanmass_sum |&gt;\n  mutate(Time = if_else(time == \"pre\", 1, 2)) |&gt;\n  ggplot( aes(Time, Median, fill = volume)) +\n    \n  \n  geom_errorbar(aes(ymin = Min, ymax = Max), \n                position = position_dodge(width = 0.4), \n                width = 0) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = Median, \n                  ymax = q75), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = q25, \n                  ymax = Median), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) +\n  \n  scale_x_continuous(limits = c(0.75, 2.25), \n                     breaks = c(1, 2), \n                     labels = c(\"pre\", \"post\"))\n\n\n\n\nDo not bother creating the above figure! This is an example of the flexibility brought to us by using a set of simple geometric objects. There are shortcuts to the above plot that takes care of a couple of default operations. We need our data prior to being summarized with additional preparatory steps:\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot()\n\n\n\n\nThe new plot is a box-plot showing the same statistical transformations that we made by hand using a categorical x-axis with the time-values sorted as a factor.\n\n\nCode producing the figure\na &lt;- leanmass_sum |&gt;\n  mutate(Time = if_else(time == \"pre\", 1, 2)) |&gt;\n  ggplot( aes(Time, Median, fill = volume)) +\n    \n  \n  geom_errorbar(aes(ymin = Min, ymax = Max), \n                position = position_dodge(width = 0.4), \n                width = 0) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = Median, \n                  ymax = q75), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = q25, \n                  ymax = Median), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) +\n  \n  scale_x_continuous(limits = c(0.75, 2.25), \n                     breaks = c(1, 2), \n                     labels = c(\"pre\", \"post\")) + \n  theme(legend.position = \"bottom\")\n  \n  \n\n\nb &lt;- leg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() + \n  theme(legend.position = \"bottom\")\n\n\n\nplot_grid(a, b, labels = c(\"a\", \"b\"), ncol = 2)\n\n\n\n\n\nA direct comparison between (a) manual statistical summaries (transformations) and built in transformations in ggplot2 (b).\n\n\n\n\nWe have seen that ggplot2 have some built in features that makes statistical transformation, but also that a similar result can be obtained by using other “geoms” such as geom_rect. Again, this allows for flexible creation of data visualizations.\n\n1.3.1 Labels and themes\nSo far we have used the available data to determine what is being represented in the figure. To make the figure closer to “publication ready” we would want to take control over labels, colors and shapes that so far are presented with variable names and default settings.\nThe labs function adds customized labels to a ggplot. All aesthetic mappings are available for labeling. We will go further with the box-plot which uses x, y and fill as aesthetics mapped to data.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\")\n\n\n\n\nAdditionally, we might want to think about if we need all axis labels. The time variable is specified with pre and post and won’t need a overall axis label. Instead we might want to clean up the axis text. Since this is a data-driven element in our figure we can change it’s behavior prior to plotting. We have already changed the order of the factor, let’s add labels to each level and remove the overall Time label.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"), \n                       labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\") +\n  \n  theme(axis.title.x = element_blank())\n\n\n\n\nNotice that we removed the “Time” label from the figure by removing it in the theme function (theme(axis.title.x = element_blank()); more about that later). The factor variable time was re-specified using the factor function. This function takes a character or factor variable and specifies levels (the order of factors) and optionally, labels for each level.\nAn alternative approach to changing the labels of the factor is to include labels in a call to scale_x_discrete.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank())\n\n\n\n\n\n1.3.1.1 Theming\nggplot2 has a very flexible system for changing parts of a figure that are not directly connected to the data (i.e. created from aesthetic mapping). Each element in the theme that can be controlled is listed in the help pages for theme, type ?theme in your console to access it.\nThe below illustrates some of the main components we might want to consider:\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\", \n       title = \"The plot title\", \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank(), \n        legend.position = \"top\",\n        axis.title = element_text(color = \"yellow\"),\n        axis.text = element_text(color = \"green\"), \n        axis.ticks = element_line(color = \"yellow\", linewidth = 2), \n        axis.line = element_line(color = \"blue\", linewidth = 2), \n        panel.background = element_rect(fill = \"gray50\"), \n        panel.grid.major = element_line(color = \"pink\", linewidth = 2), \n        panel.grid.minor = element_line(color = \"magenta\", linewidth = 2), \n        plot.background = element_rect(fill = \"darkblue\"), \n        legend.background = element_rect(fill = \"navyblue\"), \n        legend.key = element_rect(fill = \"gray\"), \n        legend.text = element_text(color = \"yellow\"), \n        legend.title = element_text(color = \"magenta\"), \n        plot.caption = element_text(color = \"yellow\"),\n        plot.title = element_text(color = \"lightgreen\"),\n        plot.subtitle = element_text(color = \"pink\"))\n\n\n\n\nEach element of the theme can be modified with an element function. The theme element axis.title is a text element and must subsequently be modified with element_text(). This function takes a number of arguments making it possible to modify text components. Below we use our basic plot and to modify the y axis title.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean\\nmass (g)\", \n       fill = \"Volume condition\", \n       title = \"The plot title\", \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank(), \n        legend.position = \"top\",\n        axis.title.y = element_text(color = \"black\", \n                                  family = \"mono\",\n                                  face = \"bold\",\n                            \n                                  size = 20,\n                                  hjust = 0.5,\n                                  vjust = 0.5,\n                                  angle = 45,\n                                  lineheight = 2),\n        )\n\n\n\n\nThe element axis.title.y is similar to axis.title.x and if we want we could use axis.title to modify both for common attributes. Notice also that we have changed multiple numbers that have defaults. The size is the size of the text, hjust and vjust controls horizontal and vertical placement, receptively.angle rotates the text and lineheight controls the distance between lines (we have used \\n to indicate a new line in the title).\nSimilarly to element_text, element_rect contains argument to control rectangular elements and element_line is used to control lines. element_blank is used to remove an element, we already used this above to remove the x axis title. In the same “family” of function we find margin which can specify margins of theme elements.\nIn addition to controlling specific elements of a theme we have the option to use ready made themes. A couple of pre-specified themes are shipped with ggplot2 (see Figure 1.4)\n\n\nCode producing the figure\np &lt;- leg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean\\nmass (g)\", \n       fill = \"Volume condition\", \n       \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\"))\n\n\n\n\nplot_grid(p + theme_bw() + labs(title = \"theme_bw\"), \n          p + theme_classic()+ labs(title = \"theme_classic\"), \n          p + theme_minimal()+ labs(title = \"theme_minimal\"), \n          p + theme_dark()+ labs(title = \"theme_dark\"), \n          p + theme_light()+ labs(title = \"theme_light\"), \n          p + theme_linedraw()+ labs(title = \"theme_linedraw\"), \n          p + theme_bw()+ labs(title = \"theme_bw\"), \n          p + theme_grey()+ labs(title = \"theme_grey\"), \n          p + theme_void()+ labs(title = \"theme_void\"), \n          ncol = 2)\n\n\n\n\n\nFigure 1.4: Examples of themes that are part of ggplot2"
  },
  {
    "objectID": "data-viz.html#edit-and-revise-in-practice",
    "href": "data-viz.html#edit-and-revise-in-practice",
    "title": "1  Data visualization",
    "section": "1.5 Edit and revise in practice",
    "text": "1.5 Edit and revise in practice\nThe process of creating graphs is an iterative practice. We try something, edit and revise. When the end result goes into a publication it is a good idea to have a workflow that updates the end result not some intermediate result.\nLet us say that we are planning to submit a paper to the American Journal of Physiology. In the author instruction we read that a single column figure should be less or equal to 8.9 cm in width and a maximum 22.8 in height/depth.9 This gives some basics instructions for our plot.9 See https://journals.physiology.org/manuscript-prep#figures\nGraphs could be created from separate R scripts. This makes the workflow smoother as we only need to run a single script to recreate the output after revision. I keep my figures together with the scripts in a dedicated folder in my project folder called figures. Here I number figures and their corresponding scripts as figure1.R, figure1.pdf, figure2.R etc.\nOn the bottom of the script I have a call to the function ggsave. This function makes it easy to save a ggplot in a number of formats, also formats accepted by journals (such as TIF and PDF).\nWhen I make changes to the script and saves them they are automatically sourced and the output is recreated."
  },
  {
    "objectID": "data-viz.html#additional-notes-tips-and-topics",
    "href": "data-viz.html#additional-notes-tips-and-topics",
    "title": "1  Data visualization",
    "section": "1.6 Additional notes, tips and topics",
    "text": "1.6 Additional notes, tips and topics\n\n1.6.1 Labels, annotations and special texts\nA package called ggtext makes it possible to write markdown syntax in labels and annotation in ggplots. This improves usability to a large degree as subscripts and superscrits together with special characters are easily added to labels etc.\nSometimes custom fonts are needed. Your basic collection of fonts are not that impressive but packages such as showtext may help in installing additional fonts.\n\n\nCode producing the figure\nlibrary(showtext)\n\nfont_add_google(name = \"Permanent Marker\", \n1                family = \"permanentmarker\")\nshowtext_auto()\n\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean\\nmass (g)\", \n       fill = \"Volume condition\", \n       title = \"The plot title\", \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank(), \n        legend.position = \"top\",\n        plot.title = element_text(color = \"black\", \n2                                  family = \"permanentmarker\",\n                                  size = 40))\n\n\n\n1\n\nThis “installs” the font on your system.\n\n2\n\nSpecifying a font family, use your own specified name to access it.\n\n\n\n\n\n\n\nAdding a silly font to a basic graph\n\n\n\n\n\n\n1.6.2 Glamorous graphics\nIn a talk at RStudio conference in 2020, Will Chase presented principles related to glamorous graphics. In contrast to Tufte’s principles (discussed above), glamorous graphics suggest adding ink to increase the attractiveness of graphics. (This might be a topic for a later workshop)."
  },
  {
    "objectID": "version-control.html#authoring-quarto-documents",
    "href": "version-control.html#authoring-quarto-documents",
    "title": "2  Version control and collaborative scientific coding",
    "section": "2.3 Authoring quarto documents",
    "text": "2.3 Authoring quarto documents\nQuarto\n\n2.3.1 Code chunks\n\n2.3.1.1 A style guide for scientific coding\nWe adhere to the tidyverse style guide. The following is a summary of the most important points with some modifications."
  },
  {
    "objectID": "version-control.html#publishing",
    "href": "version-control.html#publishing",
    "title": "2  Version control and collaborative scientific coding",
    "section": "2.4 Publishing",
    "text": "2.4 Publishing"
  },
  {
    "objectID": "writing-packages.html#footnotes",
    "href": "writing-packages.html#footnotes",
    "title": "3  R packages for data management and sharing",
    "section": "",
    "text": "Wiley marks publications with “open research badges” to indicate shared data, pre-registration and open material. The journal Biostatistics was an early adopter of marking papers with code, data and reproducible marks (Peng 2011).↩︎"
  }
]