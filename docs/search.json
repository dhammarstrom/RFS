[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Scientific Visualization, Collaboration and Thinking",
    "section": "",
    "text": "Preface\nThe purpose of this collection of workshops is to provide basic skills and understanding of scientific visualization, collaboration, and thinking. These concepts are often not taught explicitly in postgraduate courses. Instead, they are assumed to be known and understood or somehow magically infused in students through their respective scientific environments. Instead of relying on magic, professional skills should be taught and developed continuously, explicitly, and systematically.\nThe first workshop deals with data visualization which is a fundamental skill for any scientist. Data visualization, like writing, serves multiple purposes in day-to-day scientific practice. Making graphs before data collection can help the researcher better formulate the scientific problem or explain core concepts for oneself, committees or funding agencies. Visualizations will also be important for exploratory data analysis, for discovering problematic data formatting or important patterns related to the scientific problem. Lastly, visualizations will aid in communicating scientific results to other researchers and the public.\nTwo workshops are devoted to collaboration in data-intensive science. The first workshop deals with the basics of version control and the second workshop deals with structuring collected data into data packages for analysis and sharing. Version control is a way to keep track of changes in a set of files. It also provides opportunities for effective collaboration in complex projects. Using the R package system for data management and sharing is a way to ensure that data is well documented and downstream analyses are reproducible.\nThe last workshop deals with how we can develop scientific thinking using scientific models and data simulations. We will use graphical models to draw out assumptions and explore simulations as a way to test the robustness of our models and plan experiments."
  },
  {
    "objectID": "data-viz.html#a-grammar-of-graphics---ggplot2",
    "href": "data-viz.html#a-grammar-of-graphics---ggplot2",
    "title": "1  Data visualization",
    "section": "1.1 A grammar of graphics - ggplot2",
    "text": "1.1 A grammar of graphics - ggplot2\nBuilding on Wilkinsons The Grammar of Graphics (Wilkinson and Wills 2005), Wickham (Wickham 2010, 2016) implemented a graphical grammar to R through the package ggplot2. The idea behind both Wickhams and Wilkinsons formalized syntax for creating data visualizations is to avoid special cases or duplicate methods and allow for creation of data visualizations based on a set of core components used in all graphics (Wickham 2010; Wilkinson and Wills 2005).\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of Graphics. 2nd ed. Statistics and Computing. New York: Springer.\n\n———. 2016. Ggplot2 : Elegant Graphics for Data Analysis. 2nd ed. Use r! Cham: Springer International Publishing : Imprint: Springer. https://doi.org/10.1007/978-3-319-24277-4.\nThe grammar (in the version described by Wickham (Wickham 2010)) has seven components that together creates a ggplot2 visualization (Figure 1.1).\nThe underlying data contains the variables that are mapped to aesthetics such as coordinates, colors or shapes. Each aesthetic can be controlled through scales by assigning values to coordinates, colors, shapes etc. Geometric objects creates the visual representations of the mapping. Sometimes small multiples of the same graph are created using facets which creates subdivision of the data to be plotted in different panels. Statistical transformations creates summaries of the data, however, in its simplest form, the transformation is the identity transformation. All graphical representations are plotted in a coordinate system. Theme and annotations adds non-data layers to the plot which can include geometric shapes or text (Figure 1.1).\n\n\n\n\n\nFigure 1.1: Components of a ggplot2 visualization\n\n\n\n\n\n1.1.1 Building blocks of a plot\nUsing a similar example as in (Wickham 2010) a basic plot can be broken down into the data (see Table 1.1), geometric objects, scales and coordinates and annotations. These components, that can be individually manipulated, together creates the final plot (see Figure 1.2 a-d).\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics 19 (1): 3–28. https://doi.org/10.1198/jcgs.2009.07098.\n\n\n\n\n\n\nTable 1.1:  Example data for a ggplot \n  \n    \n    \n      x\n      y\n      shape\n    \n  \n  \n    1.0\n3.0\na\n    2.4\n2.0\na\n    4.0\n5.0\nb\n    5.2\n7.8\nb\n  \n  \n  \n\n\n\n\n\n\n\n\n\n\nFigure 1.2: Three components, geometric objects (a), coordinates and scales (b) and plot annotations (c) are constitues of the complete plot (d)\n\n\n\n\nThe corresponding code to create this plot is fairly straight forward:\n\nlibrary(ggplot2)\n\n1df &lt;- data.frame(x = c(1, 2.4, 4, 5.2),\n           y = c(3, 2, 5, 7.8), \n           shape = c(\"a\", \"a\", \"b\", \"b\")) \n\n\n2  ggplot(data = df,\n3         mapping = aes(x = x, y = y, shape = shape))  +\n\n4  geom_point(color = \"black\", size = 3) +\n  \n5    labs(title = \"Title\",\n       subtitle = \"Subtitle\", \n       x = \"x-axis\", \n       y = \"y-axis\", \n       shape = \"legend\") +\n6    theme_classic()\n\n\n1\n\nA simple data frame is saved containing the variables we will plot\n\n2\n\nThe data is explicitly called\n\n3\n\nVariables are mapped to coordinates (x and y) and shapes.\n\n4\n\nGeometric objects (points) are specified with color and size determined in the function\n\n5\n\nAnnotations are added to the plot through the labs (labels) function.\n\n6\n\nA pre-built theme is used to change the default appearance of the plot."
  },
  {
    "objectID": "data-viz.html#before-plotting",
    "href": "data-viz.html#before-plotting",
    "title": "1  Data visualization",
    "section": "1.2 Before plotting",
    "text": "1.2 Before plotting\nAs we saw above, a basic visualization can be created from a data set, or a data frame which is the most common representation of data in R. A tidy data set has one observation per row and one variable per column. A tidy data set makes data visualization easy. However, not all data sets are friendly. In fact, some might be unfriendly because they are unhappy1.1 The reference to happiness is a reference to Wickham (2014) wherein Tolstoy’s Anna Karenina is quoted; “Happy families are all alike; every unhappy family is unhappy in its own way.” The Anna Karenina principle applies to data as non-tidy data can be non-tidy in many ways, tidy data however are tidy because they all share a common set of features.\n———. 2014. “Tidy Data.” Journal of Statistical Software; Vol 1, Issue 10 (2014), September. https://www.jstatsoft.org/v059/i10 http://dx.doi.org/10.18637/jss.v059.i10.\n\n\n\n\nA lot of effort goes into making data sets suitable for visualization or statistical modelling. The good news is that R is especially suited for the process of importing and wrangling data. As with other common tasks in R there are numerous ways of achieving the same goals. This is a good thing because it allows for solutions to a wide range of problems. It is also a bad thing because it makes it difficult to getting started. A collection of R packages called the Tidyverse makes the process of getting started with data wrangling easier.\nTidyverse can be thought of as a dialect of the R language. The dialect is designed to make it easy to write sequential operations in a way that translates thoughts and ideas to code. Sequential operations are enabled by a pipe operator. Using a pipe operator we can call functions in sequential order to do specific operations on the data. We can write such a pipe as demonstrated below with the corresponding English language descriptions to the left.\n\n\nTake the data then do filter the data based on x larger than 10 then do add a new calculated variable z = x + y then do show the output\n\n\ndata |&gt;\n  filter(x &gt; 10) |&gt;\n  mutate(z = x + y) |&gt;\n  print()\n\n\n\nThe pipe operator (|&gt;) takes any input and place it as the first argument in the following function2. This is the mechanism that makes sequential operations possible. A pipe operator makes code more readable, consider the following two alternatives:2 A function is a basic building block of your R code. Function are designed for specific tasks and can be part of packages or created by the user. A function may take arguments such as fun(&lt;ARGUMENT1&gt; = &lt;default input&gt;, &lt;ARGUMNET2&gt; = &lt;default input&gt;). Arguments can be used without explicitly naming them by putting expected input in at the right position. Orders of argument may be changed is argument names are used.\n\n\n\n\n1print(mutate(filter(select(data, var1:var3), var1 == \"xxx\"), var4 = var1 + var2))\n\n\n2data |&gt;\n  select(var1:var3) |&gt;\n  filter(var1 == \"xxx\") |&gt;\n  mutate(var4 = var1 + var2) \n\n\n1\n\nAlternative 1: A number of operations are performed on data, we have to read from in to out to see each step.\n\n2\n\nAlternative 2: The same steps are performed as in alternative 1, in the same order.\n\n\n\n\nThe pipe in alternative 2 are structured with the pipe operator making the code more readable and easier to edit. Notice that the same functions are used in both cases.\nIn R there are two main pipe operators. We have the “base R” pipe, |&gt;. This pipe operator is included in the base installation of R and available without loading any packages on start up. A second pipe belongs to the magritter package. The magritter pipe (%&gt;%) has the same basic functionality as the base pipe; the left hand input is inserted as the first argument in any right hand function.\nSometimes you might want to place your input somewhere else than as the first argument in a right hand function. A placeholder can be used to indicate where you would like to place your input. The base pipe differs from the magritter pipe in what symbol indicates a placeholder. In the example below, the function some_fun() expects data as the third argument. We need to use our placeholder to put the data in the correct position:\n\n1data |&gt;\n  some_fun(arg1 = c(1, 2), \n           arg2 = \"some.setting\", \n           arg3 = _)\n\n\nlibrary(tidyverse)\n2data %&gt;%\n  some_fun(arg1 = c(1, 2), \n           arg2 = \"some.setting\", \n           arg3 = .)\n\n\n1\n\nWith the base R forward pipe operator.\n\n2\n\nWith the magritter forward pipe operator.\n\n\n\n\n\n1.2.1 Reading data into R\nThree packages makes reading tabular data into R easy. readr provides functions for reading and writing delimiter separated files, such as .csv or .tsv. readxl provides functions that imports data from excel files. An finally, googlesheets4 makes it possible to read tabular data created in google sheets.\nData can also be loaded from packages in R since storing data is a convenient way of sharing. By including data in a package you are nudged to do some quality checks and document it. We will talk more about data packages in a later workshop.\n\n\n1.2.2 The verbs of data wrangling\nOnce data is available in our workspace we will be able to wrangle it. In the examples below I will use a data set containing results from dual x-ray absorptiometry measurements available in the exscidata package. To install the exscidata package:\n\nlibrary(remotes)\ninstall_github(\"dhammarstrom/exscidata\")\n\nThe dplyrpackage provides a collection of verbs to facilitate wrangling. As mentioned above, “pipeable” functions takes a data frame as its first argument. This means that we can line up functions in sequential order using a pipe operator. In all verb functions, following the data argument follows a set of arguments that specifies what we wish to do with the data. The result of the operations performed by the function are returned as a data frame.\ndplyr contains the following main data verbs:\n\nselect\nrename\nrelocate\nmutate\nfilter\narrange\nsummarize\n\nIn addition, several helper function will aid our wrangling endeavors.\ndplyr is loaded as part of the tidyverse package:\n\nlibrary(tidyverse)\n\n\n1.2.2.1 Select, rename and relocate variables\nVariables in a data frame may be selected and renamed. Such operation may have multiple purposes such as giving you a better overview of the data of interest or limiting what data to display in a table. Renaming can make life easier if the data set contains long variable names.\nBelow we will store a subset of the data in a new data set. But we will first have a look at what column names are available:\n\n1library(exscidata)\n2glimpse(exscidata::dxadata)\n\n\n1\n\nLoading the exscidata package\n\n2\n\nUsing glimbse we will get a overview of all available variables in the data set. The double :: means that we are looking for the data set dxadata inside the package exscidata.\n\n\n\n\nRows: 80\nColumns: 59\n$ participant      &lt;chr&gt; \"FP28\", \"FP40\", \"FP21\", \"FP34\", \"FP23\", \"FP26\", \"FP36…\n$ time             &lt;chr&gt; \"pre\", \"pre\", \"pre\", \"pre\", \"pre\", \"pre\", \"pre\", \"pre…\n$ multiple         &lt;chr&gt; \"L\", \"R\", \"R\", \"R\", \"R\", \"R\", \"L\", \"R\", \"R\", \"L\", \"L\"…\n$ single           &lt;chr&gt; \"R\", \"L\", \"L\", \"L\", \"L\", \"L\", \"R\", \"L\", \"L\", \"R\", \"R\"…\n$ sex              &lt;chr&gt; \"female\", \"female\", \"male\", \"female\", \"male\", \"female…\n$ include          &lt;chr&gt; \"incl\", \"incl\", \"incl\", \"incl\", \"incl\", \"excl\", \"incl…\n$ age              &lt;dbl&gt; 24.5, 22.1, 26.8, 23.1, 24.8, 24.2, 20.5, 20.6, 37.4,…\n$ height           &lt;dbl&gt; 170.0, 175.0, 184.0, 164.0, 176.5, 163.0, 158.0, 181.…\n$ weight           &lt;dbl&gt; 66.5, 64.0, 85.0, 53.0, 68.5, 56.0, 60.5, 83.5, 65.0,…\n$ BMD.head         &lt;dbl&gt; 2.477, 1.916, 2.306, 2.163, 2.108, 2.866, 1.849, 2.21…\n$ BMD.arms         &lt;dbl&gt; 0.952, 0.815, 0.980, 0.876, 0.917, 0.973, 0.871, 0.91…\n$ BMD.legs         &lt;dbl&gt; 1.430, 1.218, 1.598, 1.256, 1.402, 1.488, 1.372, 1.42…\n$ BMD.body         &lt;dbl&gt; 1.044, 0.860, 1.060, 0.842, 0.925, 0.984, 0.923, 1.01…\n$ BMD.ribs         &lt;dbl&gt; 0.770, 0.630, 0.765, 0.636, 0.721, 0.737, 0.648, 0.70…\n$ BMD.pelvis       &lt;dbl&gt; 1.252, 1.078, 1.314, 1.044, 1.154, 1.221, 1.194, 1.32…\n$ BMD.spine        &lt;dbl&gt; 1.316, 0.979, 1.293, 0.899, 1.047, 1.089, 1.006, 1.14…\n$ BMD.whole        &lt;dbl&gt; 1.268, 1.082, 1.325, 1.119, 1.181, 1.350, 1.166, 1.24…\n$ fat.left_arm     &lt;dbl&gt; 1168, 715, 871, 610, 788, 372, 932, 1312, 388, 668, 5…\n$ fat.left_leg     &lt;dbl&gt; 4469, 4696, 3467, 3023, 3088, 2100, 4674, 5435, 1873,…\n$ fat.left_body    &lt;dbl&gt; 6280, 4061, 7740, 3638, 6018, 2328, 4896, 9352, 2921,…\n$ fat.left_whole   &lt;dbl&gt; 12365, 9846, 12518, 7565, 10259, 5048, 10736, 16499, …\n$ fat.right_arm    &lt;dbl&gt; 1205, 769, 871, 610, 741, 374, 940, 1292, 413, 716, 5…\n$ fat.right_leg    &lt;dbl&gt; 4497, 4900, 3444, 3017, 3254, 2082, 4756, 5455, 1782,…\n$ fat.right_body   &lt;dbl&gt; 6082, 3923, 8172, 3602, 5699, 2144, 4705, 8674, 2640,…\n$ fat.right_whole  &lt;dbl&gt; 12102, 9862, 12856, 7479, 10020, 4821, 10806, 15876, …\n$ fat.arms         &lt;dbl&gt; 2373, 1484, 1742, 1220, 1529, 747, 1872, 2604, 802, 1…\n$ fat.legs         &lt;dbl&gt; 8965, 9596, 6911, 6040, 6342, 4182, 9430, 10890, 3655…\n$ fat.body         &lt;dbl&gt; 12362, 7984, 15912, 7239, 11717, 4472, 9601, 18026, 5…\n$ fat.android      &lt;dbl&gt; 1880, 963, 2460, 1203, 1933, 527, 1663, 3183, 1240, 1…\n$ fat.gynoid       &lt;dbl&gt; 5064, 5032, 4779, 3739, 4087, 2740, 5217, 6278, 2309,…\n$ fat.whole        &lt;dbl&gt; 24467, 19708, 25374, 15044, 20278, 9869, 21542, 32375…\n$ lean.left_arm    &lt;dbl&gt; 1987, 1931, 2884, 1753, 2652, 2425, 1913, 2266, 3066,…\n$ lean.left_leg    &lt;dbl&gt; 7059, 7190, 10281, 6014, 8242, 7903, 6829, 8889, 9664…\n$ lean.left_body   &lt;dbl&gt; 9516, 10693, 13847, 9736, 11387, 10573, 8954, 11482, …\n$ lean.left_whole  &lt;dbl&gt; 20305, 21778, 29332, 19143, 24185, 22946, 18809, 2431…\n$ lean.right_arm   &lt;dbl&gt; 2049, 2081, 2888, 1754, 2487, 2439, 1930, 2236, 3253,…\n$ lean.right_leg   &lt;dbl&gt; 7104, 7506, 10200, 6009, 8685, 7841, 6950, 8923, 9198…\n$ lean.right_body  &lt;dbl&gt; 9199, 10304, 14593, 9636, 10779, 9733, 8602, 10672, 1…\n$ lean.right_whole &lt;dbl&gt; 19605, 21310, 29643, 18792, 23653, 21837, 19407, 2372…\n$ lean.arms        &lt;dbl&gt; 4036, 4012, 5773, 3508, 5139, 4864, 3843, 4501, 6319,…\n$ lean.legs        &lt;dbl&gt; 14163, 14696, 20482, 12023, 16928, 15744, 13779, 1781…\n$ lean.body        &lt;dbl&gt; 18715, 20998, 28440, 19372, 22166, 20306, 17556, 2215…\n$ lean.android     &lt;dbl&gt; 2669, 2782, 3810, 2455, 2904, 2656, 2297, 3094, 3344,…\n$ lean.gynoid      &lt;dbl&gt; 6219, 7209, 10233, 5866, 7525, 5970, 5825, 8175, 7760…\n$ lean.whole       &lt;dbl&gt; 39910, 43088, 58976, 37934, 47837, 44783, 38216, 4804…\n$ BMC.left_arm     &lt;dbl&gt; 181, 138, 204, 144, 180, 173, 140, 173, 220, 226, 225…\n$ BMC.left_leg     &lt;dbl&gt; 567, 508, 728, 441, 562, 574, 482, 631, 633, 630, 672…\n$ BMC.left_body    &lt;dbl&gt; 622, 414, 696, 367, 526, 465, 370, 629, 473, 629, 509…\n$ BMC.left_whole   &lt;dbl&gt; 1680, 1321, 1945, 1201, 1527, 1580, 1131, 1688, 1544,…\n$ BMC.right_arm    &lt;dbl&gt; 198, 150, 210, 142, 176, 183, 140, 176, 224, 251, 226…\n$ BMC.right_leg    &lt;dbl&gt; 574, 514, 739, 431, 552, 565, 491, 641, 622, 636, 690…\n$ BMC.right_body   &lt;dbl&gt; 592, 428, 730, 351, 502, 409, 358, 582, 420, 616, 483…\n$ BMC.right_whole  &lt;dbl&gt; 1582, 1288, 1958, 1130, 1451, 1466, 1229, 1668, 1478,…\n$ BMC.arms         &lt;dbl&gt; 379, 288, 414, 285, 356, 357, 280, 348, 444, 478, 451…\n$ BMC.legs         &lt;dbl&gt; 1142, 1022, 1467, 872, 1115, 1139, 974, 1272, 1255, 1…\n$ BMC.body         &lt;dbl&gt; 1214, 842, 1426, 718, 1028, 874, 728, 1211, 893, 1245…\n$ BMC.android      &lt;dbl&gt; 80, 57, 90, 44, 56, 54, 43, 77, 52, 72, 59, 60, 65, 5…\n$ BMC.gynoid       &lt;dbl&gt; 314, 285, 427, 245, 299, 262, 241, 379, 335, 378, 332…\n$ BMC.whole        &lt;dbl&gt; 3261, 2609, 3903, 2331, 2978, 3046, 2360, 3356, 3022,…\n\n\nThe data set contains 80 rows and 59 columns. The variables in the data set are described as part of the exscidata package and can be seen by typing ?dxadata in the console.\nWe will work further with lean body mass data, these are variables starting with lean.. In addition we need variables describing observations like participant, time, multiple, single, sex, include, height and weight. To select these variables we can try a couple of different approaches. The select function can select variables by name. This means that we can simply list them:\n\n1exscidata::dxadata |&gt;\n2  select(participant, time, multiple, single) |&gt;\n3  print()\n\n\n1\n\nRetrieve the data from the exscidata package\n\n2\n\nselect variables based on names\n\n3\n\nPrint the resulting data frame.\n\n\n\n\n# A tibble: 80 × 4\n   participant time  multiple single\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; \n 1 FP28        pre   L        R     \n 2 FP40        pre   R        L     \n 3 FP21        pre   R        L     \n 4 FP34        pre   R        L     \n 5 FP23        pre   R        L     \n 6 FP26        pre   R        L     \n 7 FP36        pre   L        R     \n 8 FP38        pre   R        L     \n 9 FP25        pre   R        L     \n10 FP19        pre   L        R     \n# ℹ 70 more rows\n\n\nThe above approach means a lot of work writing all columns names in the select call. An alternative approach is to select variables based on the first and last variable in a sequence. This is possible by using the syntax &lt;first column&gt;:&lt;last column&gt;.\n\nexscidata::dxadata |&gt;  \n1  select(participant:weight) |&gt;\n  print() \n\n\n1\n\nSelecting by the first and last column in a sequence.\n\n\n\n\n# A tibble: 80 × 9\n   participant time  multiple single sex    include   age height weight\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female incl     24.5   170    66.5\n 2 FP40        pre   R        L      female incl     22.1   175    64  \n 3 FP21        pre   R        L      male   incl     26.8   184    85  \n 4 FP34        pre   R        L      female incl     23.1   164    53  \n 5 FP23        pre   R        L      male   incl     24.8   176.   68.5\n 6 FP26        pre   R        L      female excl     24.2   163    56  \n 7 FP36        pre   L        R      female incl     20.5   158    60.5\n 8 FP38        pre   R        L      female incl     20.6   181    83.5\n 9 FP25        pre   R        L      male   incl     37.4   183    65  \n10 FP19        pre   L        R      male   incl     22.3   178.   73.5\n# ℹ 70 more rows\n\n\nWe also like to have the lean body mass data included in our new data set. Since all variables containing lean body mass data starts with lean. we can use a helper function to select them. Two alternatives are possible:\n\nexscidata::dxadata |&gt;  \n1  select(participant:weight, starts_with(\"lean.\")) |&gt;\n  print() \n\n\nexscidata::dxadata |&gt;  \n2  select(participant:weight, contains(\"lean.\")) |&gt;\n  print() \n\n\n1\n\nUsing starts_with to select all columns that starts with lean.\n\n2\n\nUsing containsto select all variables that contains lean.\n\n\n\n\n# A tibble: 80 × 23\n   participant time  multiple single sex    include   age height weight\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female incl     24.5   170    66.5\n 2 FP40        pre   R        L      female incl     22.1   175    64  \n 3 FP21        pre   R        L      male   incl     26.8   184    85  \n 4 FP34        pre   R        L      female incl     23.1   164    53  \n 5 FP23        pre   R        L      male   incl     24.8   176.   68.5\n 6 FP26        pre   R        L      female excl     24.2   163    56  \n 7 FP36        pre   L        R      female incl     20.5   158    60.5\n 8 FP38        pre   R        L      female incl     20.6   181    83.5\n 9 FP25        pre   R        L      male   incl     37.4   183    65  \n10 FP19        pre   L        R      male   incl     22.3   178.   73.5\n# ℹ 70 more rows\n# ℹ 14 more variables: lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;, lean.whole &lt;dbl&gt;\n# A tibble: 80 × 23\n   participant time  multiple single sex    include   age height weight\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female incl     24.5   170    66.5\n 2 FP40        pre   R        L      female incl     22.1   175    64  \n 3 FP21        pre   R        L      male   incl     26.8   184    85  \n 4 FP34        pre   R        L      female incl     23.1   164    53  \n 5 FP23        pre   R        L      male   incl     24.8   176.   68.5\n 6 FP26        pre   R        L      female excl     24.2   163    56  \n 7 FP36        pre   L        R      female incl     20.5   158    60.5\n 8 FP38        pre   R        L      female incl     20.6   181    83.5\n 9 FP25        pre   R        L      male   incl     37.4   183    65  \n10 FP19        pre   L        R      male   incl     22.3   178.   73.5\n# ℹ 70 more rows\n# ℹ 14 more variables: lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;, lean.whole &lt;dbl&gt;\n\n\nThere are other select helper functions such as ends_with and matches that work in a similar fashion as the above. all_of and any_of helps you select variables based on a vector of variables, where selects based on where a function of your choosing returns true. See ?select for a complete list.\nIn a select call we can also rename variables using the syntax &lt;new name&gt; = &lt;old name&gt;. Let’s say we want to select and rename participant:\n\nexscidata::dxadata |&gt;  \n  select(parti = participant, time:weight, starts_with(\"lean.\")) |&gt; \n  print() \n\n# A tibble: 80 × 23\n   parti time  multiple single sex    include   age height weight lean.left_arm\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1 FP28  pre   L        R      female incl     24.5   170    66.5          1987\n 2 FP40  pre   R        L      female incl     22.1   175    64            1931\n 3 FP21  pre   R        L      male   incl     26.8   184    85            2884\n 4 FP34  pre   R        L      female incl     23.1   164    53            1753\n 5 FP23  pre   R        L      male   incl     24.8   176.   68.5          2652\n 6 FP26  pre   R        L      female excl     24.2   163    56            2425\n 7 FP36  pre   L        R      female incl     20.5   158    60.5          1913\n 8 FP38  pre   R        L      female incl     20.6   181    83.5          2266\n 9 FP25  pre   R        L      male   incl     37.4   183    65            3066\n10 FP19  pre   L        R      male   incl     22.3   178.   73.5          3760\n# ℹ 70 more rows\n# ℹ 13 more variables: lean.left_leg &lt;dbl&gt;, lean.left_body &lt;dbl&gt;,\n#   lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;, lean.right_leg &lt;dbl&gt;,\n#   lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;, lean.arms &lt;dbl&gt;,\n#   lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;, lean.gynoid &lt;dbl&gt;,\n#   lean.whole &lt;dbl&gt;\n\n\nNotice how different ways of selecting variables can be combined in select.\nThe rename function makes it easy to rename variables without the need to select.\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  rename(parti = participant) |&gt;\n  print() \n\n# A tibble: 80 × 23\n   parti time  multiple single sex    include   age height weight lean.left_arm\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1 FP28  pre   L        R      female incl     24.5   170    66.5          1987\n 2 FP40  pre   R        L      female incl     22.1   175    64            1931\n 3 FP21  pre   R        L      male   incl     26.8   184    85            2884\n 4 FP34  pre   R        L      female incl     23.1   164    53            1753\n 5 FP23  pre   R        L      male   incl     24.8   176.   68.5          2652\n 6 FP26  pre   R        L      female excl     24.2   163    56            2425\n 7 FP36  pre   L        R      female incl     20.5   158    60.5          1913\n 8 FP38  pre   R        L      female incl     20.6   181    83.5          2266\n 9 FP25  pre   R        L      male   incl     37.4   183    65            3066\n10 FP19  pre   L        R      male   incl     22.3   178.   73.5          3760\n# ℹ 70 more rows\n# ℹ 13 more variables: lean.left_leg &lt;dbl&gt;, lean.left_body &lt;dbl&gt;,\n#   lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;, lean.right_leg &lt;dbl&gt;,\n#   lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;, lean.arms &lt;dbl&gt;,\n#   lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;, lean.gynoid &lt;dbl&gt;,\n#   lean.whole &lt;dbl&gt;\n\n\nIf we want to change the order of variables in a data set we can specify the order in a select call, or use relocate\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  relocate(lean.whole) |&gt;\n  print() \n\n# A tibble: 80 × 23\n   lean.whole participant time  multiple single sex    include   age height\n        &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1      39910 FP28        pre   L        R      female incl     24.5   170 \n 2      43088 FP40        pre   R        L      female incl     22.1   175 \n 3      58976 FP21        pre   R        L      male   incl     26.8   184 \n 4      37934 FP34        pre   R        L      female incl     23.1   164 \n 5      47837 FP23        pre   R        L      male   incl     24.8   176.\n 6      44783 FP26        pre   R        L      female excl     24.2   163 \n 7      38216 FP36        pre   L        R      female incl     20.5   158 \n 8      48045 FP38        pre   R        L      female incl     20.6   181 \n 9      54710 FP25        pre   R        L      male   incl     37.4   183 \n10      58740 FP19        pre   L        R      male   incl     22.3   178.\n# ℹ 70 more rows\n# ℹ 14 more variables: weight &lt;dbl&gt;, lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;\n\n\nrelocate puts the selected variable as the first column in the data set. If we want to specify the location we can use the arguments .before or .after.\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  relocate(lean.whole, .after = sex) |&gt;\n  print() \n\n# A tibble: 80 × 23\n   participant time  multiple single sex    lean.whole include   age height\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1 FP28        pre   L        R      female      39910 incl     24.5   170 \n 2 FP40        pre   R        L      female      43088 incl     22.1   175 \n 3 FP21        pre   R        L      male        58976 incl     26.8   184 \n 4 FP34        pre   R        L      female      37934 incl     23.1   164 \n 5 FP23        pre   R        L      male        47837 incl     24.8   176.\n 6 FP26        pre   R        L      female      44783 excl     24.2   163 \n 7 FP36        pre   L        R      female      38216 incl     20.5   158 \n 8 FP38        pre   R        L      female      48045 incl     20.6   181 \n 9 FP25        pre   R        L      male        54710 incl     37.4   183 \n10 FP19        pre   L        R      male        58740 incl     22.3   178.\n# ℹ 70 more rows\n# ℹ 14 more variables: weight &lt;dbl&gt;, lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;\n\n\n\n\n1.2.2.2 Creating new variables\nmutate let’s us create new variables in a data set. These can be a function of variables already in the data set or created from our input.\nLet’s create a variable representing the percentage of lean mass to body mass.\n\nexscidata::dxadata |&gt;  \n  select(participant:weight, starts_with(\"lean.\")) |&gt; \n  mutate(rel_lean_whole = 100 * ((lean.whole/1000) / weight)) |&gt;\n  relocate(rel_lean_whole) |&gt;\n  print() \n\n# A tibble: 80 × 24\n   rel_lean_whole participant time  multiple single sex    include   age height\n            &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1           60.0 FP28        pre   L        R      female incl     24.5   170 \n 2           67.3 FP40        pre   R        L      female incl     22.1   175 \n 3           69.4 FP21        pre   R        L      male   incl     26.8   184 \n 4           71.6 FP34        pre   R        L      female incl     23.1   164 \n 5           69.8 FP23        pre   R        L      male   incl     24.8   176.\n 6           80.0 FP26        pre   R        L      female excl     24.2   163 \n 7           63.2 FP36        pre   L        R      female incl     20.5   158 \n 8           57.5 FP38        pre   R        L      female incl     20.6   181 \n 9           84.2 FP25        pre   R        L      male   incl     37.4   183 \n10           79.9 FP19        pre   L        R      male   incl     22.3   178.\n# ℹ 70 more rows\n# ℹ 15 more variables: weight &lt;dbl&gt;, lean.left_arm &lt;dbl&gt;, lean.left_leg &lt;dbl&gt;,\n#   lean.left_body &lt;dbl&gt;, lean.left_whole &lt;dbl&gt;, lean.right_arm &lt;dbl&gt;,\n#   lean.right_leg &lt;dbl&gt;, lean.right_body &lt;dbl&gt;, lean.right_whole &lt;dbl&gt;,\n#   lean.arms &lt;dbl&gt;, lean.legs &lt;dbl&gt;, lean.body &lt;dbl&gt;, lean.android &lt;dbl&gt;,\n#   lean.gynoid &lt;dbl&gt;, lean.whole &lt;dbl&gt;\n\n\n\n\n\n1.2.3 From wide to long and back again\nThe dxadata data set is not a tidy data set. It contains two variables (single and multiple) that indicates which leg has been training with low and moderate volume respectively (Hammarström et al. 2020). Additionally, lean mass variables could be separated based on body half (right or left). To compare training volume we need to reformat the data set. We will start by making a smaller data set that indicate training volume per leg.\n\nHammarström, Daniel, Sjur Øfsteng, Lise Koll, Marita Hanestadhaugen, Ivana Hollan, William Apró, Jon Elling Whist, Eva Blomstrand, Bent R. Rønnestad, and Stian Ellefsen. 2020. “Benefits of higher resistance-training volume are related to ribosome biogenesis.” The Journal of physiology 598 (3): 543–65. https://doi.org/10.1113/JP278455.\nAs we have already seen, participant, single and multiple are the variables needed to make a data set that indicates training volume per leg, per participant. We will start by selecting these columns followed by pivoting the data as the volume data is located in two variables. This essentially means that we will make the data set longer.\n\nexscidata::dxadata |&gt;  \n1  select(participant, multiple, single) |&gt;\n2  pivot_longer(values_to = \"leg\", names_to = \"volume\",  cols = multiple:single) %&gt;%\n  print()\n\n\n1\n\nSelecting our variables of interest\n\n2\n\nCreating a long data set based on volume data spread over two columns.\n\n\n\n\n# A tibble: 160 × 3\n   participant volume   leg  \n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;\n 1 FP28        multiple L    \n 2 FP28        single   R    \n 3 FP40        multiple R    \n 4 FP40        single   L    \n 5 FP21        multiple R    \n 6 FP21        single   L    \n 7 FP34        multiple R    \n 8 FP34        single   L    \n 9 FP23        multiple R    \n10 FP23        single   L    \n# ℹ 150 more rows\n\n\nAs we see we now have a long data set, but it is longer than expected. The original data contains only 41 participants. As each participant has two legs we would expect 82 observations. Above we did not remove post-intervention observations and we therefore have several duplicates. This can be taken care of by using the distinct function which returns unique observations across a combination of variables.\n\nparticipant_volume &lt;- exscidata::dxadata |&gt;  \n  select(participant, multiple, single) |&gt; # \n  pivot_longer(values_to = \"leg\", names_to = \"volume\",  cols = multiple:single) %&gt;%\n1  distinct(participant, volume, leg) %&gt;%\n  print()\n\n\n1\n\nRemoves all duplicate combinations of participant, volume and leg.\n\n\n\n\n# A tibble: 82 × 3\n   participant volume   leg  \n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;\n 1 FP28        multiple L    \n 2 FP28        single   R    \n 3 FP40        multiple R    \n 4 FP40        single   L    \n 5 FP21        multiple R    \n 6 FP21        single   L    \n 7 FP34        multiple R    \n 8 FP34        single   L    \n 9 FP23        multiple R    \n10 FP23        single   L    \n# ℹ 72 more rows\n\n\nWe can save our smaller data set as participant_volume\nNext we want to create a data set of right and left leg lean mass data. We will start by selecting variables.\n\nexscidata::dxadata |&gt;  \n  select(participant, time, starts_with(\"lean.\") & ends_with(\"_leg\")) |&gt; #\n  print()\n\n# A tibble: 80 × 4\n   participant time  lean.left_leg lean.right_leg\n   &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt;          &lt;dbl&gt;\n 1 FP28        pre            7059           7104\n 2 FP40        pre            7190           7506\n 3 FP21        pre           10281          10200\n 4 FP34        pre            6014           6009\n 5 FP23        pre            8242           8685\n 6 FP26        pre            7903           7841\n 7 FP36        pre            6829           6950\n 8 FP38        pre            8889           8923\n 9 FP25        pre            9664           9198\n10 FP19        pre            9704           9806\n# ℹ 70 more rows\n\n\nNotice how & was used to create a conditional selection of variables. I addition to selecting time, include3 and participant we select variables that starts with lean. AND ends with _leg.3 The variable incl is used to indicate which participants to include in a final analysis. Included participants completed a given set of training sessions.\n\n\n\nThe resulting data set is wide. Two variables contains the same variable (lean mass), but one variable (leg) is lurking in two variables (lean.left_leg and lean.right_leg). Let’s make the data set long.\n\n3leg_leanmass &lt;- exscidata::dxadata |&gt;\n  select(participant, time, include, starts_with(\"lean.\") & ends_with(\"_leg\")) |&gt; \n1  pivot_longer(names_to = \"leg\", values_to = \"lean_mass\", cols = contains(\"lean.\")) |&gt;\n2  mutate(leg = if_else(leg == \"lean.left_leg\", \"L\", \"R\")) |&gt;\n  \n  print()\n\n\n1\n\nNotice how select helpers can be used in pivot_longer.\n\n2\n\nWe use mutate together with if_else to change the leg indicator to R and L\n\n3\n\nWe save the data set as leg_leanmass\n\n\n\n\n# A tibble: 160 × 5\n   participant time  include leg   lean_mass\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;\n 1 FP28        pre   incl    L          7059\n 2 FP28        pre   incl    R          7104\n 3 FP40        pre   incl    L          7190\n 4 FP40        pre   incl    R          7506\n 5 FP21        pre   incl    L         10281\n 6 FP21        pre   incl    R         10200\n 7 FP34        pre   incl    L          6014\n 8 FP34        pre   incl    R          6009\n 9 FP23        pre   incl    L          8242\n10 FP23        pre   incl    R          8685\n# ℹ 150 more rows\n\n\npivot_longer has a brother called pivot_wider, this functions performs the reverse operation making long data sets wide. Let’s say that we would like to calculate the paired difference of leg lean mass from pre to post, we could make a wider data set and calculate post - pre\n\nexscidata::dxadata |&gt;  \n  select(participant, time, include, starts_with(\"lean.\") & ends_with(\"_leg\")) |&gt; \n  pivot_longer(names_to = \"leg\", values_to = \"lean_mass\", cols = contains(\"lean.\")) |&gt;\n  mutate(leg = if_else(leg == \"lean.left_leg\", \"L\", \"R\")) |&gt; \n1  pivot_wider(names_from = time, values_from = lean_mass) |&gt;\n2  mutate(delta_lean_mass = post - pre) |&gt;\n  print()\n\n\n1\n\nPivot wider creates new columns based on names in time and values in lean_mass\n\n2\n\nThe new variables is calculated as the difference between pre and post-intervention values.\n\n\n\n\n# A tibble: 82 × 6\n   participant include leg     pre  post delta_lean_mass\n   &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;\n 1 FP28        incl    L      7059  7273             214\n 2 FP28        incl    R      7104  7227             123\n 3 FP40        incl    L      7190  7192               2\n 4 FP40        incl    R      7506  7437             -69\n 5 FP21        incl    L     10281 10470             189\n 6 FP21        incl    R     10200 10819             619\n 7 FP34        incl    L      6014  6326             312\n 8 FP34        incl    R      6009  6405             396\n 9 FP23        incl    L      8242  8687             445\n10 FP23        incl    R      8685  8480            -205\n# ℹ 72 more rows\n\n\n\n\n1.2.4 Joining data sets\nWe have constructed two smaller data sets, one indicating which leg performed low and moderate volume and one data set containing the lean mass values for each leg, pre- and post-intervention. Next step is to join the two.\ndplyr contains functions for joining data frames. There are, as illustrated in Figure 1.3 important differences between the functions where outer joins (left, right and full) keeps all observations in x, y and both x and y respectively. inner_join however, drops unmatched observations from both input data frames. Unlike the others, anti_join function removes observations in x that is present in y.\n\n\nCode producing the figure\nlibrary(ggVennDiagram) \nlibrary(ggplot2) \nlibrary(cowplot)\n\n# Joins can be illustrated with venn diagrams.\n# We do not need information about sets etc only \n# a way to fill three distinct areas. \n# The ggVennDiagram contains a function creating \n# shapes to be filled.\n\n\nlst &lt;- process_data(Venn(list(x = c(\"1\"), y = c(\"1\"))))\n\n# To avoid repeated code, create a function that plots\n# venn diagrams with options to indicate a title and \n# specify fill colors\njoin_illustration &lt;- function(lst, \n                              fills = c(\"steelblue\", \n                                        \"steelblue\", \n                                        \"white\"), \n                              title = \"left_join(x,y)\") {\n  \n  ggplot() + \n    \n  geom_sf(aes(fill = id), data = venn_region(lst), \n          color = \"black\") +\n  \n  theme_void() +\n  # Hard coded labels\n  geom_text(aes(x = c(300, 700), \n                y = c(500, 500), \n                label = c(\"x\", \"y\")), \n            size = 8, \n            color = \"gray20\") +\n  \n  \n  scale_fill_manual(values = fills) +\n  \n  labs(title = title) +\n  \n  theme(legend.position = \"none\")\n  \n  \n}\n\n\n# Each join gets its own fig. All figures are \n# ombined below with plot_grid from cowplot.\n\nleft &lt;- join_illustration(lst = lst, \n                  title = \"left_join(x,y)\", \n                  fills = c(\"steelblue\", \"steelblue\", \"white\"))\nright &lt;- join_illustration(lst = lst, \n                  title = \"right_join(x,y)\", \n                  fills = c(\"white\", \"steelblue\", \"steelblue\"))\ninner &lt;- join_illustration(lst = lst, \n                  title = \"inner_join(x,y)\", \n                  fills = c(\"white\", \"steelblue\", \"white\"))\nfull &lt;- join_illustration(lst = lst, \n                  title = \"full_join(x,y)\", \n                  fills = c(\"steelblue\", \"steelblue\", \"steelblue\"))\nanti &lt;- join_illustration(lst = lst, \n                  title = \"anti_join(x,y)\", \n                  fills = c(\"steelblue\", \"white\", \"white\"))\n\n\nplot_grid(left, right, inner, full, anti, ncol = 2)\n\n\n\n\n\nFigure 1.3: Functions for joining data sets.\n\n\n\n\nOur two data sets are pretty insensitive to dropped observations since the two data sets should be complete. We will use a left_join to put the data set together. This will match participant and leg because these two variables exists in both data sets. If we want to join by other variables we may specify such a variable. We’ll save the joined data set as leg_leanmass.\n\nleg_leanmass &lt;- leg_leanmass |&gt;\n  inner_join(participant_volume) |&gt;\n  print()\n\nJoining with `by = join_by(participant, leg)`\n\n\n# A tibble: 160 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP28        pre   incl    L          7059 multiple\n 2 FP28        pre   incl    R          7104 single  \n 3 FP40        pre   incl    L          7190 single  \n 4 FP40        pre   incl    R          7506 multiple\n 5 FP21        pre   incl    L         10281 single  \n 6 FP21        pre   incl    R         10200 multiple\n 7 FP34        pre   incl    L          6014 single  \n 8 FP34        pre   incl    R          6009 multiple\n 9 FP23        pre   incl    L          8242 single  \n10 FP23        pre   incl    R          8685 multiple\n# ℹ 150 more rows\n\n\n\n\n1.2.5 Filters and sorting rows\nWe included the variable include in our data set, this will make it possible to get rid of observations from participants that should be part of the final analysis. We can use filter to perform this operation.\n\nleg_leanmass |&gt;\n  filter(include == \"incl\") |&gt;\n  print()\n\n# A tibble: 136 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP28        pre   incl    L          7059 multiple\n 2 FP28        pre   incl    R          7104 single  \n 3 FP40        pre   incl    L          7190 single  \n 4 FP40        pre   incl    R          7506 multiple\n 5 FP21        pre   incl    L         10281 single  \n 6 FP21        pre   incl    R         10200 multiple\n 7 FP34        pre   incl    L          6014 single  \n 8 FP34        pre   incl    R          6009 multiple\n 9 FP23        pre   incl    L          8242 single  \n10 FP23        pre   incl    R          8685 multiple\n# ℹ 126 more rows\n\n\nThe double equal sign can be read as “equal to” in R, a common source of confusion is that the single equal sign (=) is used as a assignment operator.44 An assignment operator is used to assign data values to objects stored in the work space. The commonly used &lt;- is equivalent to =. Note however that -&gt; is different from =.\n\n\n\nThe filter function keeps rows of a data frame where a condition that we specify returns TRUE. To construct testable conditions that allows for results being either FALSE or TRUE we will use one, or a combination operators, such as\n\n\n\n==\n→ “equal to”\n\n\n!=\n→ “not equal to”\n\n\n&gt;\n→ “larger than”\n\n\n&lt;\n→ “smaller than”\n\n\n&gt;=, &lt;=\n→ “larger/smaller or equal to”\n\n\n!\n→ “NOT”\n\n\n&\n→ “AND”\n\n\n|\n→ “OR”\n\n\n\nThe above are all part of a collection of logical operators.5 We may demonstrate the mechanism by which filter operates by creating our own vector of TRUE/FALSE values. In the code chunk below a vector (INCLUDE) is created based on our include variable. A logical vector is created from the statement INCLUDE != \"excl\". We then use this vector in the filter statement.5 See here for a technical overview of logical operators.\n\n\n\n\nINCLUDE &lt;- leg_leanmass |&gt;\n  pull(include)\n\nINCLUDE &lt;- INCLUDE != \"excl\"\n\n\nINCLUDE\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[121]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[133]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[145]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[157] FALSE FALSE FALSE FALSE\n\nleg_leanmass |&gt;\n  filter(INCLUDE)\n\n# A tibble: 136 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP28        pre   incl    L          7059 multiple\n 2 FP28        pre   incl    R          7104 single  \n 3 FP40        pre   incl    L          7190 single  \n 4 FP40        pre   incl    R          7506 multiple\n 5 FP21        pre   incl    L         10281 single  \n 6 FP21        pre   incl    R         10200 multiple\n 7 FP34        pre   incl    L          6014 single  \n 8 FP34        pre   incl    R          6009 multiple\n 9 FP23        pre   incl    L          8242 single  \n10 FP23        pre   incl    R          8685 multiple\n# ℹ 126 more rows\n\n\nIn R, a vector of TRUE/FALSE (or in short form T/F) are is a special case which R will prohibit us from overwriting.\n\n1.2.5.1 Grouped filters\nUsing the dplyr syntax it is easy to e.g. filter or mutate based on a grouping of the data set. The function group_by creates a grouped data set. In the context of filtering in our data set we may want to filter out observations larger than the median from two time points.\n\nleg_leanmass |&gt;\n  group_by(time) |&gt;\n  filter(lean_mass &gt; median(lean_mass)) |&gt; \n  print()\n\n# A tibble: 80 × 6\n# Groups:   time [2]\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP21        pre   incl    L         10281 single  \n 2 FP21        pre   incl    R         10200 multiple\n 3 FP23        pre   incl    R          8685 multiple\n 4 FP38        pre   incl    L          8889 single  \n 5 FP38        pre   incl    R          8923 multiple\n 6 FP25        pre   incl    L          9664 single  \n 7 FP25        pre   incl    R          9198 multiple\n 8 FP19        pre   incl    L          9704 multiple\n 9 FP19        pre   incl    R          9806 single  \n10 FP13        pre   incl    L         10086 multiple\n# ℹ 70 more rows\n\n\nThe above operation removed exactly half of the observations, as expected since we wanted observations larger than the median from both time points. We may combine this statement with filtering away \"excl\" from the include variable.\n\nleg_leanmass |&gt;\n  group_by(time) |&gt;\n  filter(include != \"excl\", lean_mass &gt; median(lean_mass)) |&gt; \n  print()\n\n# A tibble: 68 × 6\n# Groups:   time [2]\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP21        pre   incl    L         10281 single  \n 2 FP21        pre   incl    R         10200 multiple\n 3 FP23        pre   incl    R          8685 multiple\n 4 FP38        pre   incl    L          8889 single  \n 5 FP38        pre   incl    R          8923 multiple\n 6 FP25        pre   incl    L          9664 single  \n 7 FP25        pre   incl    R          9198 multiple\n 8 FP19        pre   incl    L          9704 multiple\n 9 FP19        pre   incl    R          9806 single  \n10 FP13        pre   incl    L         10086 multiple\n# ℹ 58 more rows\n\n\nPutting two conditions in a filter call is like explicitly using & (AND) to combine statements. All conditions must evaluate to be TRUE for the row to be included in final output.\nAn alternative to grouping by the group_by function is to do a “per-operation grouping”6 using the .by argument. This does not leave a grouping in the data frame after filtering.6 See ?dplyr_by\n\nleg_leanmass |&gt;\n  filter(include != \"excl\", lean_mass &gt; median(lean_mass), .by = time) |&gt; \n  print()\n\n# A tibble: 68 × 6\n   participant time  include leg   lean_mass volume  \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   \n 1 FP21        pre   incl    L         10281 single  \n 2 FP21        pre   incl    R         10200 multiple\n 3 FP23        pre   incl    R          8685 multiple\n 4 FP38        pre   incl    L          8889 single  \n 5 FP38        pre   incl    R          8923 multiple\n 6 FP25        pre   incl    L          9664 single  \n 7 FP25        pre   incl    R          9198 multiple\n 8 FP19        pre   incl    L          9704 multiple\n 9 FP19        pre   incl    R          9806 single  \n10 FP13        pre   incl    L         10086 multiple\n# ℹ 58 more rows\n\n\n\n\n\n1.2.6 Summaries\nWe often want to reduce larger amount of data into some summaries, such as means, standard deviations, medians etc. These summaries may be calculated over any number of categorical variables representing e.g. groups of observations. Just like in the filtering statement above, we may work with a grouped data frame, or by using a per-operation grouping (.by).\nWe will calculate the median, first and third quartile, and minimum and maximum from each volume condition and time point. Below are both of the two alternatives of grouping used.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  group_by(time, volume) |&gt;\n  summarise(Min = min(lean_mass), \n            q25 = quantile(lean_mass, 0.25), \n            Median = median(lean_mass), \n            q75 = quantile(lean_mass, 0.75), \n            Max = max(lean_mass)) |&gt;\n  print()\n\n`summarise()` has grouped output by 'time'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 4 × 7\n# Groups:   time [2]\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 post  multiple  5343 7309.  8654. 10820. 13948\n2 post  single    5561 7201.  8772. 10453. 13526\n3 pre   multiple  5500 7010.  8590. 10104  13166\n4 pre   single    5289 7126.  8654  10125. 13166\n\nleanmass_sum &lt;- leg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  summarise(Min = min(lean_mass), \n            q25 = quantile(lean_mass, 0.25), \n            Median = median(lean_mass), \n            q75 = quantile(lean_mass, 0.75), \n            Max = max(lean_mass), \n            .by = c(time, volume)) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   multiple  5500 7010.  8590. 10104  13166\n2 pre   single    5289 7126.  8654  10125. 13166\n3 post  multiple  5343 7309.  8654. 10820. 13948\n4 post  single    5561 7201.  8772. 10453. 13526\n\n\nNotice how the data frames either have a persistent grouping, or no grouping depending on how we invoked grouping. Notice also that all values are nicely displayed, this is not always the case with summarise.\nConsider the following example\n\nvals &lt;- c(4.5, 6.7, 4.6, 5.1, NA)\n\nmean(vals)\n\n[1] NA\n\n\nThe mean of a vector of values containing a missing value returns NA. If we where to have missing values (NA) in our original data we would have recievied a NA in results. To drop an NA from such a summary we need to specify na.rm = TRUE as part of a summary function.\n\nvals &lt;- c(4.5, 6.7, 4.6, 5.1, NA)\n\nmean(vals, na.rm = TRUE)\n\n[1] 5.225\n\n\nR does not drop NA silently! This is a good thing as we want to get a notice when we are missing data. If we know we are missing data we need to explicitly type this in our calls. This “rule” is not always true as some functions silently drops NA, be aware!\n\n\n1.2.7 Arranging data frames\nAt last we might want to arrange a data frame for ease of use, or prior to making a table etc. Arranging does not change the data frame per se, only how it is displayed.\nWe’ll used our summarized data frame from above and sort based on the volume variable.\n\nleanmass_sum |&gt;\n  arrange(volume) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   multiple  5500 7010.  8590. 10104  13166\n2 post  multiple  5343 7309.  8654. 10820. 13948\n3 pre   single    5289 7126.  8654  10125. 13166\n4 post  single    5561 7201.  8772. 10453. 13526\n\n\nAny other column will also work for arranging\n\nleanmass_sum |&gt;\n  arrange(Median) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   multiple  5500 7010.  8590. 10104  13166\n2 post  multiple  5343 7309.  8654. 10820. 13948\n3 pre   single    5289 7126.  8654  10125. 13166\n4 post  single    5561 7201.  8772. 10453. 13526\n\n\nUsing a helper function (desc) reverses the sorting\n\nleanmass_sum |&gt;\n  arrange(desc(Median)) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 post  single    5561 7201.  8772. 10453. 13526\n2 pre   single    5289 7126.  8654  10125. 13166\n3 post  multiple  5343 7309.  8654. 10820. 13948\n4 pre   multiple  5500 7010.  8590. 10104  13166\n\n\nNotice that desc also works for character data\n\nleanmass_sum |&gt;\n  arrange(desc(volume)) |&gt;\n  print()\n\n# A tibble: 4 × 7\n  time  volume     Min   q25 Median    q75   Max\n  &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 pre   single    5289 7126.  8654  10125. 13166\n2 post  single    5561 7201.  8772. 10453. 13526\n3 pre   multiple  5500 7010.  8590. 10104  13166\n4 post  multiple  5343 7309.  8654. 10820. 13948"
  },
  {
    "objectID": "data-viz.html#scientific-graphic-design",
    "href": "data-viz.html#scientific-graphic-design",
    "title": "1  Data visualization",
    "section": "1.4 Scientific graphic design",
    "text": "1.4 Scientific graphic design\nTufte (Tufte 2001) provides us with several principles for creating effective data visualizations.\n\nTufte, Edward R. 2001. The Visual Display of Quantitative Information. 2. edition. Cheshire, Conn.: Graphics Press.\n\nShow the data\nMaximize the data-ink ratio\nErase non-data ink\nErase redundant data ink\nRevise and edit\n\n\n1.4.1 Chartjunk\nSee ggpattern etc for creating chart junk with ggplot2\n\n\n1.4.2 Minimizing\nSee ggthemes for range-frame as suggested in tufte Ch 6. Manually minimize summary displays such as boxplots…\n\n\n1.4.3 Labels and annotations\nUsing ggtext to format labels etc.\nChanging fonts\n\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\n?font_add_google\n\nstarting httpd help server ...\n\n\n done\n\nfont_add_google(name = \"Permanent Marker\", family = \"permanentmarker\")\nshowtext_auto()\n\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean\\nmass (g)\", \n       fill = \"Volume condition\", \n       title = \"The plot title\", \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank(), \n        legend.position = \"top\",\n        plot.title = element_text(color = \"black\", \n                                  family = \"permanentmarker\",\n                         \n                            \n                                  size = 40,\n                             \n                                  lineheight = 2),\n        )\n\n\n\n\n\n\n1.4.4 Glamorous graphics\nIn a talk at RStudio conference in 2020, Will Chase presented principles related to glamorous graphics.\nWhy glamorous graphics? - Engage a wider audience - Aesthetics matters for understanding - “respecting the audience”\nThe glamour of graphics uses color, typography and layout to increase the impact of the graphic.\n\n\n1.4.5 Layout\n\n1.4.5.1 Alignment\nTop left align titles\nText should be horizontal\nAxis labels should also be horizontal\nAlignment should provide clean lines and symmetry\nSome alignment can be left/center/right to provide overall structure to the graph.\n\n\n1.4.5.2 Border, Grid lines, legends\nDo not use borders or grid lines. If grid lines, make them lighter and more subtle.\nAvoid legends, labels of the data are better or titles with color.\n\n\n1.4.5.3 White space\nUse white space to separate elements of the graph and give the reader room to understand the graph.\n\n\n\n1.4.6 Typography\n\n1.4.6.1 Fonts\n\n\n1.4.6.2 Hierarchy\nThis gives the reader a hierarchy of information.\n\n\n\n1.4.7 Color\nWhat colors look good together?\n\n# Load required libraries\nlibrary(ggplot2)\n\n# Create a data frame of angles and radii\nangles &lt;- seq(0, 360, by = 0.1)\nradii &lt;- seq(0.1, 1, by = 0.1)  # Vary the starting point to avoid a point at the center\ndf &lt;- expand.grid(angle = angles, radius = radii)\n\n# Create ggplot of colored points in polar coordinates\np &lt;- ggplot(df, aes(x = angle, y = radius, color = angle, alpha = radius)) +\n  geom_point(size = 8) +\n  scale_color_gradientn(colors = rainbow(360)) +\n  scale_alpha_continuous(range = c(1, 0.1)) +\n  coord_polar(theta = \"x\") +\n  theme_void() +\n  theme(axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"none\")\n  \n\n#### Alternative\n\n# Create a data frame of angles from 0 to 360\nangles &lt;- seq(0, 360, by = 0.2)\ndf &lt;- data.frame(angle = angles)\n\n# Create ggplot of colored points in polar coordinates\np &lt;- ggplot(df, aes(x = angle, y = 1, color = angle)) +\n  geom_point(size = 10) +\n  scale_color_gradientn(colors = rainbow(360)) +\n  coord_polar(theta = \"x\") +\n  theme_void() +\n  theme(axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"none\")\n\nThe color wheel can be used to find\n\nComplementary colors that will give high contrast\nMonochromatic will give harmonious\n\nAnalogous are choosen from the same side on the color wheele colors to avoid contrast but still enable showing differences\nTriadic colors to give more\n\n\n\n1.4.7.1 Describing colors, Hue, Saturation and Lightness\n\n\n1.4.7.2 Background colors\nColors can help reduce “hardness” by avoiding a white background."
  },
  {
    "objectID": "version-control.html#introduction-to-git-and-github",
    "href": "version-control.html#introduction-to-git-and-github",
    "title": "2  Version control and collaborative scientific coding",
    "section": "2.1 Introduction to git and GitHub",
    "text": "2.1 Introduction to git and GitHub"
  },
  {
    "objectID": "version-control.html#a-workflow-for-a-scientific-paper",
    "href": "version-control.html#a-workflow-for-a-scientific-paper",
    "title": "2  Version control and collaborative scientific coding",
    "section": "2.2 A workflow for a scientific paper",
    "text": "2.2 A workflow for a scientific paper\n\n2.2.1 The final result\n\n\n2.2.2 Initial setup\n\n\n2.2.3 Repositories and branches\n\n\n2.2.4 Milestones, issues, and pull requests\n\n\n2.2.5 A style guide for scientific coding\nWe adhere to the tidyverse style guide. The following is a summary of the most important points with some modifications.\n\n\n2.2.6 Publishing"
  },
  {
    "objectID": "writing-packages.html#increased-reproducibility",
    "href": "writing-packages.html#increased-reproducibility",
    "title": "3  R packages for data management and sharing",
    "section": "3.1 Increased reproducibility",
    "text": "3.1 Increased reproducibility\nA basic principle in reproducible research is that the data and code used to generate results should be made available to others."
  },
  {
    "objectID": "writing-packages.html#r-package-basics",
    "href": "writing-packages.html#r-package-basics",
    "title": "3  R packages for data management and sharing",
    "section": "3.2 R package basics",
    "text": "3.2 R package basics\n\n3.2.1 Incorporating data into R packages\n\n\n3.2.2 Documenting data"
  },
  {
    "objectID": "writing-packages.html#sharing-packages",
    "href": "writing-packages.html#sharing-packages",
    "title": "3  R packages for data management and sharing",
    "section": "3.3 Sharing packages",
    "text": "3.3 Sharing packages"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Gelman, Andrew, Cristian Pasarica, and Rahul Dodhia. 2002. “Let’s\nPractice What We Preach.” The American Statistician 56\n(2): 121–30. https://doi.org/10.1198/000313002317572790.\n\n\nHammarström, Daniel, Sjur Øfsteng, Lise Koll, Marita Hanestadhaugen,\nIvana Hollan, William Apró, Jon Elling Whist, Eva Blomstrand, Bent R.\nRønnestad, and Stian Ellefsen. 2020. “Benefits of higher\nresistance-training volume are related to ribosome biogenesis.”\nThe Journal of physiology 598 (3): 543–65. https://doi.org/10.1113/JP278455.\n\n\nTufte, Edward R. 2001. The Visual Display of Quantitative\nInformation. 2. edition. Cheshire, Conn.: Graphics Press.\n\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.”\nJournal of Computational and Graphical Statistics 19 (1): 3–28.\nhttps://doi.org/10.1198/jcgs.2009.07098.\n\n\n———. 2014. “Tidy Data.” Journal of Statistical\nSoftware; Vol 1, Issue 10 (2014), September. https://www.jstatsoft.org/v059/i10\nhttp://dx.doi.org/10.18637/jss.v059.i10.\n\n\n———. 2016. Ggplot2 : Elegant Graphics for Data Analysis. 2nd\ned. Use r! Cham: Springer International Publishing : Imprint: Springer.\nhttps://doi.org/10.1007/978-3-319-24277-4.\n\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of\nGraphics. 2nd ed. Statistics and Computing. New York: Springer."
  },
  {
    "objectID": "data-viz.html#ggplot-examples",
    "href": "data-viz.html#ggplot-examples",
    "title": "1  Data visualization",
    "section": "1.3 ggplot examples",
    "text": "1.3 ggplot examples\nAs hinted above, ggplot2 presents us with almost endless opportunities for graphical representations of our data. We will use the data we have wrangled above to better understand the ggplot2 syntax.\nIn our summary of the lean mass data we have calculated a number of summary statistics that can be used to create a type of range-quartile-median plot not unlike the plots suggested by Tukey7. We will use time as a categorical variable on the x-axis and our summary statistics displayed on the y-axis.7 Tukey (1977) is considered to be creator of the box-plot. However, Spear may have suggested a predecessor to the box-plot in Charting statistics (Spear 1952).\nTukey, John Wilder. 1977. Exploratory Data Analysis. Addison-Wesley Series in Behavioral Science. Reading, Mass: Addison-Wesley Pub. Co.\n\nSpear, M. E. 1952. Charting Statistics. McGraw-Hill. https://books.google.no/books?id=1vBOAAAAMAAJ.\n\n\nggplot(data = leanmass_sum, aes(time, Median))\n\n\n\n\nWe have specified a data set, and variables for the x and y axis. This specification gives us an empty coordinate system. We need to add geometric objects to represent the data mapped to x and y coordinates. Let’s start simple\n\nggplot(data = leanmass_sum, aes(time, Median)) +\n    geom_point()\n\n\n\n\nThe points now represents our median values per time point. Instead of a point we may add rectangular shapes with a bit of reorganization of the data\n\nleanmass_sum |&gt;\n  mutate(Time = if_else(time == \"pre\", 1, 2)) |&gt;\n  ggplot( aes(Time, Median, fill = volume)) +\n    \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = Median, \n                  ymax = q75), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) + \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = q25, \n                  ymax = Median), \n            color = \"black\", \n            position = position_dodge(width = 0.4))\n\n\n\n\nWe have hacked our way to a plot showing the median as a line inside a box covering the interquartile range. Let’s add bars representing the minimum and maximum values. Note that we are using layers and we want our range bars to not over plot the boxes. We must therefore add them prior to the boxes. We will also scale the x-axis and add labels.\n\nleanmass_sum |&gt;\n  mutate(Time = if_else(time == \"pre\", 1, 2)) |&gt;\n  ggplot( aes(Time, Median, fill = volume)) +\n    \n  \n  geom_errorbar(aes(ymin = Min, ymax = Max), \n                position = position_dodge(width = 0.4), \n                width = 0) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = Median, \n                  ymax = q75), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = q25, \n                  ymax = Median), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) +\n  \n  scale_x_continuous(limits = c(0.75, 2.25), \n                     breaks = c(1, 2), \n                     labels = c(\"pre\", \"post\"))\n\n\n\n\nDo not bother creating the above plot! This is an example of the flexibility brought to us by using a set of simple geometric objects. There are shortcuts to the above plot that takes care of a couple of default operations. We need our pre-summarized data with additional preparatory steps:\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot()\n\n\n\n\nThe new plot is a box-plot showing the same statistical transformations that we made by hand using a categorical x-axis with the time-values sorted as a factor.\n\n\nCode producing the figure\na &lt;- leanmass_sum |&gt;\n  mutate(Time = if_else(time == \"pre\", 1, 2)) |&gt;\n  ggplot( aes(Time, Median, fill = volume)) +\n    \n  \n  geom_errorbar(aes(ymin = Min, ymax = Max), \n                position = position_dodge(width = 0.4), \n                width = 0) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = Median, \n                  ymax = q75), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) + \n  \n  \n  geom_rect(aes(xmin = Time - 0.18, \n                  xmax = Time + 0.18, \n                  ymin = q25, \n                  ymax = Median), \n            color = \"black\", \n            position = position_dodge(width = 0.4)) +\n  \n  scale_x_continuous(limits = c(0.75, 2.25), \n                     breaks = c(1, 2), \n                     labels = c(\"pre\", \"post\")) + \n  theme(legend.position = \"bottom\")\n  \n  \n\n\nb &lt;- leg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() + \n  theme(legend.position = \"bottom\")\n\n\n\nplot_grid(a, b, labels = c(\"a\", \"b\"), ncol = 2)\n\n\n\n\n\nA direct comparison between (a) manual statistical summaries (transformations) and built in transformations in ggplot2 (b).\n\n\n\n\nWe have seen that ggplot2 have some built in features that makes statistical transformation, but also that a similar result can be obtained by using other “geoms” such as geom_rect. Again, this allows for flexible creation of data visualizations.\n\n1.3.1 Labels and themes\nSo far we have used the available data to determine what is being represented in the figure. To make the figure more publication ready we would want to take control over labels, colors and shapes that so far are presented with variable names and default settings.\nThe labs function adds customized labels to a ggplot. All aesthetic mappings are available for labeling. We will go further with the box-plot which uses x, y and fill as aesthetics mapped to data.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\")\n\n\n\n\nAdditionally, we might want to think about if we need all axis labels. The time variable is specified with pre and post and won’t need a overall axis label. Instead we might want to clean up the axis text. Since this is a data-driven element in our figure we can change it’s behaviour prior to plotting. We have already changed the order of the factor, let’s add a labels to each level and remove the overall Time label.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"), \n                       labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\") +\n  \n  theme(axis.title.x = element_blank())\n\n\n\n\nNotice that we removed the “Time” label from the figure by removing it in the theme function (theme(axis.title.x = element_blank()); more about that later). The factor variable timewas respecified using the factor function. This function takes a character of factor varaible and specifies levels (the order of factors) and optionally labels of each level.\nAn alternative approach to changing the labels of the factor is to include labels in a call to scale_x_discrete.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank())\n\n\n\n\n\n1.3.1.1 Theming\nggplot2 has a very flexible system for changing parts of a figure that are not directly connected to the data (i.e. created from aesthetic mapping). Each element in the theme that can be controlled is listed in the help pages for theme, type ?theme in your console to access it.\nThe below illustrates some of the main components we might want to consider:\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean mass (g)\", \n       fill = \"Volume condition\", \n       title = \"The plot title\", \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank(), \n        legend.position = \"top\",\n        axis.title = element_text(color = \"yellow\"),\n        axis.text = element_text(color = \"green\"), \n        axis.ticks = element_line(color = \"yellow\", linewidth = 2), \n        axis.line = element_line(color = \"blue\", linewidth = 2), \n        panel.background = element_rect(fill = \"gray50\"), \n        panel.grid.major = element_line(color = \"pink\", linewidth = 2), \n        panel.grid.minor = element_line(color = \"magenta\", linewidth = 2), \n        plot.background = element_rect(fill = \"darkblue\"), \n        legend.background = element_rect(fill = \"navyblue\"), \n        legend.key = element_rect(fill = \"gray\"), \n        legend.text = element_text(color = \"yellow\"), \n        legend.title = element_text(color = \"magenta\"), \n        plot.caption = element_text(color = \"yellow\"),\n        plot.title = element_text(color = \"lightgreen\"),\n        plot.subtitle = element_text(color = \"pink\"))\n\n\n\n\nEach element of the theme can be modified with a element function. The element theme axis.title is a text element and must subsequently be modified with element_text(). This function takes a number of arguments making it possible to modify text components. Below use our basic plot and to modify the y axis title.\n\nleg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean\\nmass (g)\", \n       fill = \"Volume condition\", \n       title = \"The plot title\", \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\")) +\n  \n  \n  theme(axis.title.x = element_blank(), \n        legend.position = \"top\",\n        axis.title.y = element_text(color = \"black\", \n                                  family = \"mono\",\n                                  face = \"bold\",\n                            \n                                  size = 20,\n                                  hjust = 0.5,\n                                  vjust = 0.5,\n                                  angle = 45,\n                                  lineheight = 2),\n        )\n\n\n\n\nNotice how the element axis.title.y is similar to axis.title.x and if we want we could use axis.title to modify both. Notice also that we have changed multiple numbers that have defaults. The size is the size of the text, hjust and vjust controls horizontal and vertical placement, receptively.angle rotates the text and lineheight controls the distance between lines (we have used \\n to indicate a new line in the title).\nSimilarly to element_text, element_rect contains argument to control rectangular elements and element_line is used to control lines. element_blank is used to remove an element, we already used this above to remove the x axis title. In the same “family” of function we find margin which can specify margins of theme elements.\nIn addition to controlling specific elements of a theme we have the option to use ready made themes. A couple of pre-specified themes are shipped with ggplot2 (see Figure 1.4)\n\n\nCode producing the figure\np &lt;- leg_leanmass |&gt;\n  filter(include != \"excl\") |&gt;\n  mutate(time = factor(time, \n                       levels = c(\"pre\", \"post\"))) |&gt;\n\nggplot(aes(time, lean_mass, fill = volume)) + \n         geom_boxplot() +\n  \n  labs(x = \"Time\", \n       y = \"Leg lean\\nmass (g)\", \n       fill = \"Volume condition\", \n       \n       subtitle = \"The plot subtitle\", \n       caption = \"the plot caption\") +\n  \n  scale_x_discrete(labels = c(\"Pre\\nintervention\", \n                                  \"Post\\nintervention\"))\n\n\n\n\nplot_grid(p + theme_bw() + labs(title = \"theme_bw\"), \n          p + theme_classic()+ labs(title = \"theme_classic\"), \n          p + theme_minimal()+ labs(title = \"theme_minimal\"), \n          p + theme_dark()+ labs(title = \"theme_dark\"), \n          p + theme_light()+ labs(title = \"theme_light\"), \n          p + theme_linedraw()+ labs(title = \"theme_linedraw\"), \n          p + theme_bw()+ labs(title = \"theme_bw\"), \n          p + theme_grey()+ labs(title = \"theme_grey\"), \n          p + theme_void()+ labs(title = \"theme_void\"), \n          ncol = 2)\n\n\n\n\n\nFigure 1.4: Examples of themes that are part of ggplot2"
  }
]